Goã‚¤ãƒ³ãƒˆãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³
Tokyo, Japan
10 Dec 2016

Dave Cheney
dave@cheney.net
http://dave.cheney.net/
@davecheney

* ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã¨è³‡æ–™ã«ã¤ã„ã¦

ã“ã®ãƒ—ãƒ¬ã‚¼ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã¯[[https://creativecommons.org/licenses/by-sa/4.0/][ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ– ã‚³ãƒ¢ãƒ³ã‚º è¡¨ç¤º ç¶™æ‰¿ 4.0 å›½éš›]]ã®ä¸‹ã«æä¾›ã•ã‚Œã¦ã„ã¾ã™ã€‚

ãƒ—ãƒ¬ã‚¼ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã®è³‡æ–™ã¯Githubä¸Šã§å…¥æ‰‹ã§ãã¾ã™ã€‚

.link https://github.com/davecheney/introduction-to-go


è³‡æ–™ã«å¯¾ã—ã¦ãƒªãƒŸãƒƒã‚¯ã‚¹ã€æ”¹å¤‰ã€æ§‹ç¯‰ã‚’ã™ã‚‹éš›ã¯é©åˆ‡ãªã‚¯ãƒ¬ã‚¸ãƒƒãƒˆã‚’è¡¨ç¤ºã—ã€åŒã˜ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ä¸‹ã§å†é…å¸ƒã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

ã‚‚ã—ã“ã®ãƒ—ãƒ¬ã‚¼ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã«ã¤ã„ã¦ææ¡ˆã‚„ä¿®æ­£ãŒã‚ã‚‹å ´åˆã¯ã€[[https://github.com/davecheney/introduction-to-go/isues][GitHubãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¤ã‚·ãƒ¥ãƒ¼ã‚’ä½œæˆã—ã¦ãã ã•ã„]]

* ã‚¢ã‚¸ã‚§ãƒ³ãƒ€

ã“ã®ãƒ¯ãƒ¼ã‚¯ã‚·ãƒ§ãƒƒãƒ—ã¯ä»–ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã®çµŒé¨“ãŒã‚ã‚Šã€Goã«ãã®ã‚¹ã‚­ãƒ«ã‚’é©ç”¨ã™ã‚‹æ–¹æ³•ã‚’å­¦ã³ãŸã„ãƒ—ãƒ­ã‚°ãƒ©ãƒãƒ¼ã‚’å¯¾è±¡ã«ã—ã¦ã„ã¾ã™ã€‚

ã“ã®ãƒ¯ãƒ¼ã‚¯ã‚·ãƒ§ãƒƒãƒ—ã¯5ã¤ã®ãƒ¡ã‚¤ãƒ³ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§æ§‹æˆã•ã‚Œã¦ã„ã¾ã™ã€‚

- åŸºæœ¬æ§‹æ–‡
- é«˜åº¦ãªæ§‹æ–‡Advanced Syntax
- é–‹ç™ºç’°å¢ƒã¨ãƒ„ãƒ¼ãƒ«
- æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒª
- ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¨ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³

å„ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®å¾Œã«ã¯è³ªå•ã®ãŸã‚ã®æ™‚é–“ãŒã‚ã‚Šã¾ã™ã€‚

ç§ãŸã¡ãŒä»Šæ—¥å–ã‚Šçµ„ã‚“ã§ã„ã‚‹é–“ã¯ä¼šè©±ãŒå°‘ãªããªã‚Šã€Goã‚’ç¿’å¾—ã™ã‚‹ã®ã«å½¹ç«‹ã¤ã‚¨ã‚¯ã‚µã‚µã‚¤ã‚ºã‚’å¤šãè¡Œã„ã¾ã™ã€‚

* ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªGo

- ãƒ¢ãƒ€ãƒ³
- ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆ, å®Œçµ, æ±ç”¨çš„
- å‘½ä»¤å‹, é™çš„å‹ãƒã‚§ãƒƒã‚¯, å‹•çš„å‹å®‰å…¨
- ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³
- é™çš„ãƒªãƒ³ã‚¯ã•ã‚ŒãŸãƒã‚¤ãƒ†ã‚£ãƒ–ã‚³ãƒ¼ãƒ‰ã¸ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«
- é«˜é€Ÿãªã‚³ãƒ³ãƒ‘ã‚¤ãƒ«, åŠ¹ç‡çš„ãªå®Ÿè¡Œ

ãƒ—ãƒ­ã‚°ãƒ©ãƒãƒ¼ãŒãƒ—ãƒ­ã‚°ãƒ©ãƒãƒ¼ã®ãŸã‚ã«è¨­è¨ˆã—ã¾ã—ãŸï¼

.link https://talks.golang.org/2014/taste.slide#2 å‡ºå…¸: Robert Griesemer, A Taste of Go.

* é€Ÿåº¦

Goã¯é«˜é€Ÿãªã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã§ã‚ˆãçŸ¥ã‚‰ã‚Œã¦ã„ã¾ã™ãŒã€ã“ã‚Œã¯GoãŒãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã™ã‚‹ãŸã‚ã« _é€Ÿã„_ è¨€èªã§ã‚ã‚‹ã¨ã„ã†ã‚¢ã‚¤ãƒ‡ã‚¢ã®ã»ã‚“ã®ä¸€é¢ã«éãã¾ã›ã‚“ã€‚

ã€Œé™çš„è¨€èªãŒ "é…ãã¦è‹¦ç—›" ã§ã‚ã‚Šã€å‹•çš„è¨€èªãŒ "é€Ÿãã¦æ¥½ã—ã„" ã¨ã„ã†èª¤ã£ãŸäºŒåˆ†æ³•ã€ - Rob Pike

ã€Œä¸‹æ‰‹ãªå‹ã‚·ã‚¹ãƒ†ãƒ ã¯äººã€…ã‚’å‹•çš„ã«å‹ä»˜ã‘ã•ã‚ŒãŸè¨€èªã¸è¿½ã„ã‚„ã‚‹ã€ - Robert Griesemer

Goã¯ä½œæˆã—ãŸãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¨ã„ã†ç‚¹ã§é«˜é€Ÿã§ã‚ã‚Šã€ä½œæˆè€…ã«ã¨ã£ã¦ã‚‚é«˜é€Ÿï¼ˆç”Ÿç”£çš„ï¼Ÿï¼‰ã§ã‚ã‚‹ã¨ã„ã†ä¸¡æ–¹ã‚’å¯èƒ½ã«ã™ã‚‹è¨€èªã¨ã„ã†ã“ã¨ã‚’å®Ÿè¨¼ã™ã‚‹ã“ã¨ã‚’è©¦ã¿ã¦ã„ã¾ã™ã€‚

* å®‰å…¨æ€§

- å‹æŒ‡å®š, ãã—ã¦å‹å®‰å…¨

 var i int = -1
 var u uint = 200
 i = u   // ãƒ€ãƒ¡ã§ã™, äº’æ›æ€§ã®ãªã„å‹ã§ã™

- é…åˆ—ã‚¢ã‚¯ã‚»ã‚¹ã§ã¯å¢ƒç•Œãƒã‚§ãƒƒã‚¯ã•ã‚Œã‚‹

 s := make([]string, 10)
 x := s[20] // å®Ÿè¡Œæ™‚ã«panicã—ã¾ã™

- æ˜ç¤ºçš„ã«åˆæœŸåŒ–ã•ã‚Œãªã„å ´åˆã€å…¨ã¦ã®ãƒ¡ãƒ¢ãƒªã¯ã‚¼ãƒ­ã«ãªã£ã¦ã„ã¾ã™

 var q int       // 0 ã§åˆæœŸåŒ–ã•ã‚Œã¾ã™
 var f = 7       // 7 ã§åˆæœŸåŒ–ã•ã‚Œ, ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å‹ã¯intã«ãªã‚Šã¾ã™

- æš—é»™çš„ãªå¤‰æ›ã¯ã—ã¾ã›ã‚“ã€‚ãƒ–ãƒ¼ãƒ«å€¤ã¨æ•´æ•°ã¯ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã§ã¯ã‚ã‚Šã¾ã›ã‚“

 i := 2
 if i { ... }    // ãƒ€ãƒ¡ã§ã™, ãƒ–ãƒ¼ãƒ«ã¸ã®å‹å¼·åˆ¶ã¯ã‚ã‚Šã¾ã›ã‚“

* ä¸¦è¡Œå‡¦ç†ã¨é€šä¿¡ã®å„ªã‚ŒãŸã‚µãƒãƒ¼ãƒˆ

- ãƒãƒ«ãƒã‚³ã‚¢CPUãŒç¾å®Ÿã®ã‚‚ã®ã«ãªã‚Šã¾ã™ã€‚
- ãƒãƒ«ãƒãƒ—ãƒ­ã‚»ãƒƒã‚·ãƒ³ã‚°ãŒè§£æ±ºç­–ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
- ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã«çµ±åˆã•ã‚ŒãŸãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å‡¦ç†ã¯æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«çµ„ã¿è¾¼ã¾ã‚Œã¦ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã™ã€‚

* ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³

Goã¯ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’æŒã¤è¨€èªã§ã™ã€‚

- å…±æœ‰ã•ã‚ŒãŸå€¤ã®æ‰€æœ‰æ¨©ã«é–¢é€£ã™ã‚‹è¨˜éŒ²ã®ã‚¨ãƒ©ãƒ¼ã‚’æ’é™¤ã—ã¾ã™
- Eliminates an entire class of use after free and memory leak bugs.ï¼ˆï¼Ÿï¼‰
- ã‚ˆã‚Šã‚·ãƒ³ãƒ—ãƒ«ã§ã‚¯ãƒªãƒ¼ãƒ³ãªAPIã‚’å¯èƒ½ã«ã—ã¦ã„ã¾ã™ã€‚

The garbage collector handles heaps into the 100's of GB range, and is designed for extremely low "stop the world" pauses.ï¼ˆï¼Ÿï¼‰

(ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚¿ã¯GBã®ç¯„å›²ã®ãƒ’ãƒ¼ãƒ—ã‚’å‡¦ç†ã—ã€ãã—ã¦ã¨ã¦ã‚‚çŸ­ã„"ä¸–ç•Œã‚’æ­¢ã‚ã‚‹"åœæ­¢æ™‚é–“ã®ãŸã‚ã«è¨­è¨ˆã•ã‚Œã¦ã„ã¾ã™ )

Go 1.7ã§ã¯ã€ã“ã‚Œã‚‰ã®åœæ­¢æ™‚é–“ã¯100ãƒã‚¤ã‚¯ãƒ­ç§’æœªæº€ã«ãªã£ã¦ã„ã¾ã™ã€‚

* Opinionated

Goã¯è‡ªåˆ†ã®æ„è¦‹ã‚’æŒã£ãŸè¨€èªã§ã™ã€‚

- æœªä½¿ç”¨ã®ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã¯ã‚¨ãƒ©ãƒ¼ã¨ãªã‚Šã¾ã™ã€‚
- æœªä½¿ç”¨ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚‚ã¾ãŸã‚¨ãƒ©ãƒ¼ã¨ãªã‚Šã¾ã™ã€‚
- ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯è­¦å‘Šã‚’å‡ºåŠ›ã—ã¾ã›ã‚“ã€‚ã‚¨ãƒ©ãƒ¼ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚
- `go`fmt` ãŒã‚³ãƒ¼ãƒ‰ã®æ›¸å¼ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã™ã‚‹å˜ä¸€ã®æ–¹æ³•ã«ãªã‚Šã¾ã™ã€‚

* ãƒãƒ­ãƒ¼, http!

.play -edit src/hellohttp/hellohttp_jp.go

* åŸºæœ¬æ§‹æ–‡

* åŸºæœ¬æ§‹æ–‡

ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯ã€ç°¡å˜ãªGoãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®åŸºæœ¬æ§‹æ–‡ã«ã¤ã„ã¦èª¬æ˜ã—ã¦ã„ãã¾ã™ã€‚

ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®å…¨ã¦ã®æ¼”ç¿’ã‚³ãƒ¼ãƒ‰ã¯ã‚¹ãƒ©ã‚¤ãƒ‰ã®ä¸­ã«çµ„ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã™ã€‚

ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’çµ‚ãˆã‚‹ã¨æ¬¡ã®ã“ã¨ãŒåˆ†ã‹ã‚‹ã§ã—ã‚‡ã†ã€‚

- å®šæ•°ã¨å¤‰æ•°ã®å®£è¨€æ–¹æ³•
- `for` ãƒ«ãƒ¼ãƒ—ã¨ `if` ã®ä½¿ã„æ–¹
- å‹ã®ä»•çµ„ã¿
- ç‹¬è‡ªã®é–¢æ•°ã®æ›¸ãæ–¹
- ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¨ `import` æ–‡ã®ä»•çµ„ã¿

* å®šæ•°

_å®šæ•°_ ã¯Goã«ã¤ã„ã¦è©±ã—å§‹ã‚ã‚‹ã®ã«è‰¯ã„ç®‡æ‰€ã§ã—ã‚‡ã†ã€‚

å®šæ•°ã¯å¤‰ã‚ã‚‰ãªã„å€¤ã§ã™

ä»¥ä¸‹ã¯å®šæ•°ã®ä¾‹ã¨ãªã‚Šã¾ã™

 1
 "ã“ã‚“ã«ã¡ã¯"
 false
 1.3

ã“ã‚Œã‚‰ã¯å€¤ã®è©•ä¾¡ãŒå®šæ•°è‡ªä½“ã«ã‚ˆã£ã¦è¡Œã‚ã‚Œã¦ãŠã‚Šã€ _ãƒªãƒ†ãƒ©ãƒ«å®šæ•°_ ã¨å‘¼ã°ã‚Œã¾ã™

* å®šæ•°ã®å‹

å®šæ•°ã®å‹ã«ã¯6ç¨®é¡ã‚ã‚Šã¾ã™

- æ•´æ•°å®šæ•°: `1`, `0`, `-6`, `9999999999999999999`, â€¦
- æµ®å‹•ç‚¹å°æ•°: `3.14`, `7.5e-2`, â€¦
- è¤‡ç´ æ•°å®šæ•°ï¼ˆã¾ã‚Œï¼‰: `1`-`0.707i`, â€¦
- æ–‡å­—åˆ—å®šæ•°: `"Hello,`æ±äº¬"`, â€¦
- ãƒ«ãƒ¼ãƒ³å®šæ•°: `'a'`, `'ã™'`, `'ã‚·'`, `'1'`, â€¦
- ãƒ–ãƒ¼ãƒ«å®šæ•°: `true`, `false`

* const

å®šæ•°ã‚’ä½œã‚‹ã«ã¯ã€ `const` ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã§å®šæ•°ã‚’å®£è¨€ã—ã¾ã™

.play -edit src/const/const1/main.go /START OMIT/,/END OMIT/

ã‚¹ãƒ©ã‚¤ãƒ‰ä¸Šã§ *Run* ãƒœã‚¿ãƒ³ãŒè¡¨ç¤ºã•ã‚ŒãŸæ™‚ã¯ã€ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

- *Run* ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ã€ä½•ãŒèµ·ã“ã‚‹ã‹è¦‹ã¦ã¿ã¦ãã ã•ã„
- *Close* ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã¨ã€å‡ºåŠ›ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãŒé–‰ã˜ã¾ã™

ã‚¹ãƒ©ã‚¤ãƒ‰å†…ã®ã‚³ãƒ¼ãƒ‰ã‚’ç›´æ¥ç·¨é›†ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚


- ã‚³ãƒ¼ãƒ‰ã‚’ç·¨é›†ã—ã€åå‰ã‚’ã‚ãªãŸã®ã‚‚ã®ã«ç½®ãæ›ãˆã¦ãã ã•ã„
- Goã®å…¨ã¦ã®ã‚³ãƒ¼ãƒ‰ã¯ UTF-8ãªã®ã§ã€æ¼¢å­—ã‚’ä½¿ã†ã“ã¨ãŒå‡ºæ¥ã¾ã™
- *Run* ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦çµæœã‚’è¦‹ã¦ã¿ã¦ãã ã•ã„
- ã‚‚ã—é–“é•ãˆãŸå ´åˆã¯ã€ãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„

* è­˜åˆ¥å­

_è­˜åˆ¥å­_ ã«ã¤ã„ã¦è©±ã™è‰¯ã„æ©Ÿä¼šã§ã™ã­

è­˜åˆ¥å­ã¨ã¯ã€ã‚³ãƒ¼ãƒ‰å†…ã®ä½•ã‹ã«ä»˜ã‘ã‚‹åå‰ã§ã™

Goã®è­˜åˆ¥å­ã¯ã€_æ–‡å­—_ ã§å§‹ã¾ã‚‹å˜èªã«ãªã‚Šã¾ã™

.play -edit src/identifier/identifier1/main.go /START OMIT/,/END OMIT/

æ–‡å­—ã¨ã¯Unicodeä¸Šã§æ–‡å­—ã¨ã—ã¦å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ã§ã€æ¼¢å­—ã‚„ã‚­ãƒªãƒ«æ–‡å­—ã€ãƒ©ãƒ†ãƒ³æ–‡å­—ãªã©ãŒå«ã¾ã‚Œã¾ã™ã€‚

- è­˜åˆ¥å­ã¯ASCIIæ–‡å­—ã«åˆ¶é™ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ã‚¹ãƒ©ã‚¤ãƒ‰ã‚’ç·¨é›†ã—ã€ `students` ã‚’ `å­¦ç”Ÿæ•°` ã¸å¤‰æ›´ã—ã¦ *Run* ã‚’æŠ¼ã—ã¦ã¿ã¾ã—ã‚‡ã†
- ã‚‚ã—é–“é•ãˆãŸå ´åˆã¯ã€ãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„

* è­˜åˆ¥å­ (ç¶šã)

è­˜åˆ¥å­ã¯ã€Unicodeæ–‡å­—ã¾ãŸã¯ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ï¼ˆ_ï¼‰ã§å§‹ã¾ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™

æ•°å€¤ã¯è­˜åˆ¥å­ã®å…ˆé ­ã§ã¯è¨±å¯ã•ã‚Œã¦ã„ã¾ã›ã‚“ãŒã€2æ–‡å­—ç›®ä»¥é™ã§ã¯å¯èƒ½ã§ã™

.play -edit src/identifier/identifier2/main.go /START OMIT/,/END OMIT/

ã“ã‚Œã‚‰ã¯ _ç„¡åŠ¹ãª_ è­˜åˆ¥å­ã®ä¾‹ã¨ãªã‚Šã¾ã™

- ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹ã‚ˆã†ã«è­˜åˆ¥å­ã®åå‰ã‚’å¤‰æ›´ã—ã¦ãã ã•ã„
- *Run* ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦çµæœã‚’ç¢ºèªã—ã¦ã¿ã¦ãã ã•ã„
- ã‚‚ã—é–“é•ãˆãŸå ´åˆã¯ã€ãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„

* ã‚³ãƒ¡ãƒ³ãƒˆ

Goã¯2ç¨®é¡ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™

- ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã‚³ãƒ¡ãƒ³ãƒˆã¯äºŒé‡ã®ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã€Œ//ã€ã§å§‹ã¾ã‚Šã¾ã™
- ãƒ–ãƒ­ãƒƒã‚¯ã‚³ãƒ¡ãƒ³ãƒˆã¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã¨ã‚¹ã‚¿ãƒ¼ã€Œ/*ã€ã§å§‹ã¾ã‚Šã€ã‚¹ã‚¿ãƒ¼ã¨ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã€Œ* /ã€ã§çµ‚ã‚ã‚Šã¾ã™

.play -edit src/comments/comments1/main.go /START OMIT/,/END OMIT/

ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã€å®Ÿè¡Œã•ã‚Œã¾ã›ã‚“ã€‚

- ã“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚’å‰Šé™¤ã—ã¦ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹ã‚ˆã†ã«ã—ã¦ãã ã•ã„
- *Run* ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦çµæœã‚’ç¢ºèªã—ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œ`1`2`3`ãŒå‡ºåŠ›ã•ã‚Œã¾ã™
- ã‚‚ã—é–“é•ãˆãŸå ´åˆã¯ã€ãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„

* å®£è¨€

Goã® _å®£è¨€_ ã«ã¯6ç¨®é¡ã‚ã‚Šã€æ—¢ã«ãã®ã†ã¡ã®1ã¤ã¯è¦‹ã¦ã„ã¾ã™ã€‚

ãã‚Œã‚‰ã¯ã€

- `const`: æ–°ã—ã„å®šæ•°ã‚’å®£è¨€ã—ã¾ã™
- `var`: æ–°ã—ã„å¤‰æ•°ã‚’å®£è¨€ã—ã¾ã™
- `type`: æ–°ã—ã„å‹ã‚’å®£è¨€ã—ã¾ã™
- `func`: æ–°ã—ã„é–¢æ•°ã€ã¾ãŸã¯ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®£è¨€ã—ã¾ã™
- `package`: ãã® `.go` ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ãŒå±ã™ã‚‹ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’å®£è¨€ã—ã¾ã™
- `import`: ãã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãŒä»–ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®å®£è¨€ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹å®£è¨€ã‚’ã—ã¾ã™

ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯æ®‹ã‚Šã®5ã¤ã®å®£è¨€ã«ã¤ã„ã¦ãã‚Œãã‚Œèª¬æ˜ã—ã¾ã™ã€‚

* å¤‰æ•°

å¤‰æ•°ã¯ãã®ã†ã¡ã«å¤‰æ›´ãŒå¯èƒ½ãªå€¤ã‚’ä¿æŒã—ã¾ã™ã€‚

`var` å®£è¨€ã«ã‚ˆã£ã¦æ–°ã—ã„å¤‰æ•°ã‚’ _å®£è¨€_ ã—ã¾ã™

.play -edit src/variable/variable1/main_jp.go /START OMIT/,/END OMIT/

å®šæ•°ã®ã‚ˆã†ã«ã€å¤‰æ•°ã® _è­˜åˆ¥å­_ ã¯Unicodeã¨ã—ã¦æœ‰åŠ¹ãªæ–‡å­—ã‚’ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚

- *Run* ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦çµæœã‚’ç¢ºèªã—ã¦ãã ã•ã„

_æ³¨_ï¼š å††å‘¨ã¯ç§‘å­¦çš„è¨˜æ•°æ³•ã§å‡ºåŠ›ã•ã‚Œã¦ã„ã¾ã™ğŸ˜• ã§ã™ãŒå¤§ä¸ˆå¤«ã§ã™ã€‚å¾Œã§ `fmt` ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã«ã¤ã„ã¦è©±ã™æ™‚ã«ä¿®æ­£ã™ã‚‹æ–¹æ³•ã‚’è©±ã—ã¾ã™ã€‚

* æœªä½¿ç”¨å¤‰æ•°ã®å®£è¨€

æœªä½¿ç”¨ã®å¤‰æ•°ã¯ã‚ˆããƒã‚°ã®åŸå› ã¨ãªã‚Šã¾ã™ã€‚ã‚‚ã—é–¢æ•°ã®ã‚¹ã‚³ãƒ¼ãƒ—å†…ã§å¤‰æ•°ã‚’å®£è¨€ã—ãã‚Œã‚’ä½¿ã‚ãªã‹ã£ãŸã‚‰ã€Goã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯æ–‡å¥ã‚’è¨€ã†ã§ã—ã‚‡ã†ã€‚

ã‚‚ã—å¤‰æ•°ãŒæœªä½¿ç”¨ãªã‚‰ã€ãã‚Œã‚’å‰Šé™¤ã™ã‚‹ã‹ã€ä¸€æ™‚çš„ã« `_` ã¨ã„ã†ãƒã‚¸ãƒƒã‚¯å¤‰æ•°ã¸ä»£å…¥ã™ã¹ãã§ã™ã€‚

.play -edit src/variable/variable2/main.go /START OMIT/,/END OMIT/

ã“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ã¯4ã¤ã®æœªä½¿ç”¨ã®å¤‰æ•°ãŒã‚ã‚Šã¾ã™ã€‚

- ä¸‹ã®2è¡Œã®ã‚³ãƒ¡ãƒ³ãƒˆã‚’å–ã‚Šé™¤ãã‚ˆã†ã«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ä¿®æ­£ã—ã¦ãã ã•ã„
- `è‡ªè»¢è»Š` ã®å®£è¨€ã¯ä½¿ã‚ã‚Œã¦ã„ãªã„ã®ã§ã€å‰Šé™¤ã¾ãŸã¯ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã—ã¦ãã ã•ã„
- *Run* ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºã‹ã‚ã¦ãã ã•ã„

* å‘½ä»¤æ–‡

_å‘½ä»¤æ–‡_ ã¯ä½•ã‹ã‚’è¡Œã†ãŸã‚ã®ã‚³ãƒãƒ³ãƒ‰ã§ã™ã€‚

- æ–°ã—ã„intå‹å¤‰æ•°xã‚’å®£è¨€ã—ã€å€¤ã«10ã‚’å‰²ã‚Šå½“ã¦ã‚‹
- xã«4ã‚’åŠ ãˆã€çµæœã‚’yã«æ ¼ç´ã™ã‚‹
- xãŒ20æœªæº€ã®å ´åˆã¯ä»¥ä¸‹ã®å‘½ä»¤æ–‡ã‚’å®Ÿè¡Œã™ã‚‹

Goã«ã¯ã„ãã¤ã‹ã®ç¨®é¡ã®å‘½ä»¤æ–‡ãŒã‚ã‚Šã¾ã™ãŒã€ã™ã§ã«ã„ãã¤ã‹è¦‹ã¦ãã¾ã—ãŸã€‚ æœ€ã‚‚ä¸€èˆ¬çš„ãªå‘½ä»¤æ–‡ã¯æ¬¡ã®ã¨ãŠã‚Šã§ã™ã€‚

- å®£è¨€: `const`pi`=`3.14159265359`, `type`Counter`int32`, â€¦
- ä»£å…¥: `count`=`count`+`1`, â€¦
- ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ/ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ: `x++`, `y--`
- æ¡ä»¶: `if`â€¦`{`â€¦`}`else`{`â€¦`}`, `switch`{`â€¦`}`
- ãƒ«ãƒ¼ãƒ—: `for`â€¦`{`â€¦`}`
- åˆ¶å¾¡ãƒ•ãƒ­ãƒ¼: `break`, `fallthrough`, `continue`, `goto`, `return`.

* ä»£å…¥

å¤‰æ•°ã«æ ¼ç´ã•ã‚Œã¦ã„ã‚‹å€¤ã¯å¤‰æ›´ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã®ãŒæ™®é€šã§ã™ã€‚ã“ã‚Œã¯ _ä»£å…¥_ ã¨å‘¼ã°ã‚Œã¾ã™ã€‚

.play -edit src/assignment/assignment1/main.go /START OMIT/,/END OMIT/

ã“ã®ä¾‹ã§ã¯ã€ï¼ˆã‚’å®£è¨€ã—ã¦ã„ã¾ã™ï¼‰

- *Run* ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦  `1`, `2`, `4` ãŒå‡ºåŠ›ã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºã‹ã‚ã¦ãã ã•ã„
# - `y` ã‚ˆã‚Šã‚‚2å€å¤§ããªå€¤ã‚’ã‚‚ã¤æ–°ãŸãªå¤‰æ•° `z` ã‚’å®£è¨€ã™ã‚‹ã‚ˆã†ã«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›´æ–°ã—ã¦ãã ã•ã„

* ä»£å…¥ ï¼ˆç¶šãï¼‰

æ–°ã—ã„å€¤ã¯ _å¤‰æ•°_ ã«ã ã‘ä»£å…¥ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

.play -edit src/assignment/assignment2/main.go /START OMIT/,/END OMIT/

å®šæ•°ã«æ–°ã—ã„å€¤ã‚’ä»£å…¥ã™ã‚‹ã¨ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ã‚¨ãƒ©ãƒ¼ã«ãªã‚Šã¾ã™ã€‚

- *Run* ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã§ããªã„ã“ã¨ã‚’è¦‹ã¦ã¿ã¦ãã ã•ã„ã€‚
- ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã‚’ç·¨é›†ã—ã€`x` ã®å®£è¨€ã‚’å®šæ•°(`const`)ã‹ã‚‰å¤‰æ•°(`var`)ã¸å¤‰ãˆã¦ãã ã•ã„
- *Run* ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã€æ­£ã—ã„ç­”ãˆã® 2 ãŒå‡ºåŠ›ã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºã‹ã‚ã¦ãã ã•ã„

* ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã¨ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ

Goã¯é™ã‚‰ã‚ŒãŸå½¢å¼ã®å¾Œç½®ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã¨å¾Œç½®ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚
ä¾‹.  `x++`, `x--`

.play -edit src/increment/increment1/main.go /START OMIT/,/END OMIT/

- *Run* ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒ2ã‚’å‡ºåŠ›ã™ã‚‹ã“ã¨ã‚’è¦‹ã¦ã¿ã¦ãã ã•ã„
- ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã‚’ç·¨é›†ã—ã€ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆæ¼”ç®—å­ `i--` ã‚’ä½¿ã£ã¦ `i` ã‹ã‚‰ `1` ã‚’å¼•ã„ã¦ãã ã•ã„
- *Run* ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã€æ­£ã—ã„ç­”ãˆã® 0 ãŒå‡ºåŠ›ã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºã‹ã‚ã¦ãã ã•ã„

* ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã¨ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆï¼ˆç¶šãï¼‰

`i++` ã¨ `i--` ã¯ _å‘½ä»¤æ–‡_ ã§ã‚ã‚Šã€ _å¼_ ã§ã¯ãªã„ãŸã‚ã€å€¤ã‚’ç”Ÿã¿å‡ºã—ã¾ã›ã‚“ã€‚

.play -edit src/increment/increment2/main.go /START OMIT/,/END OMIT/

ã“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ã¯ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ã‚¨ãƒ©ãƒ¼ãŒã‚ã‚Šã¾ã™ã€‚

- `i++` å‘½ä»¤æ–‡ã‚’ `var`j` å®£è¨€ã®ä¸Šã¸ç§»å‹•ã•ã›ã¦ã‚¨ãƒ©ãƒ¼ã‚’ç›´ã™ã‚ˆã†ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã‚’ç·¨é›†ã—ã¦ãã ã•ã„
- *Run* ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã€æ­£ã—ã„ç­”ãˆã® 2, 2 ãŒå‡ºåŠ›ã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºã‹ã‚ã¦ãã ã•ã„

* ãƒ«ãƒ¼ãƒ—

Goã«ã¯å˜ä¸€ã® `for` ãƒ«ãƒ¼ãƒ—æ§‹é€ ãŒã‚ã‚Šã€

- `while` _æ¡ä»¶_ `{`â€¦`}`
- `do`{`â€¦`}`while` _æ¡ä»¶_
- `do`{`â€¦`}`until` _æ¡ä»¶_

ã‚’ä¸€ã¤ã®æ§‹æ–‡ã¸ã¨ã¾ã¨ã‚ã¦ã„ã¾ã™ã€‚

- `for` _(åˆæœŸåŒ–)_; _æ¡ä»¶_; _(äº‹å¾Œå‡¦ç†)_ `{`â€¦`}`

`for`æ–‡ã®æ§‹æˆã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚

- åˆæœŸåŒ–ï¼š ãƒ«ãƒ¼ãƒ—å¤‰æ•°ã®åˆæœŸåŒ–ã®ãŸã‚ã«ä½¿ã‚ã‚Œã¾ã™; `i`=`0`
- æ¡ä»¶ï¼š ãƒ«ãƒ¼ãƒ—ãŒçµ‚äº†ã™ã‚‹ã‹ã©ã†ã‹ã®ãŸã‚ã«ä½¿ã‚ã‚Œã¾ã™; `i`<`10` ãŒ `çœŸ` ãªã‚‰ãƒ«ãƒ¼ãƒ—ãŒç¶šãã¾ã™
- äº‹å¾Œå‡¦ç†ï¼š ãƒ«ãƒ¼ãƒ—å¤‰æ•°ã®å¢—åˆ†ã®ãŸã‚ã«ä½¿ã‚ã‚Œã¾ã™; `i++`, `i`=`i`-`1`

* ãƒ«ãƒ¼ãƒ— ï¼ˆç¶šãï¼‰

ãƒ«ãƒ¼ãƒ—ã®ç·´ç¿’ã‚’ã—ã¾ã—ã‚‡ã†ã€‚

.play -edit src/loops/loops1/main.go /START OMIT/,/END OMIT/

ã“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ `1` ã‹ã‚‰ `10` ã¾ã§æ•°ãˆã¾ã™ãŒã€ _å¶æ•°_ ã ã‘ã‚’å‡ºåŠ›ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã‹ã€‚

- ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ç·¨é›†ã—ã€ `1` ã‹ã‚‰ `10` ã¾ã§ã®å¶æ•°ã ã‘ã‚’å‡ºåŠ›ã™ã‚‹ã‚ˆã†ã«ã—ã¦ãã ã•ã„ã€‚
- *Run* ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã€æ­£ã—ã„ç­”ãˆã® `2`, `4`, `6`, `8`, `10` ãŒå‡ºåŠ›ã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºã‹ã‚ã¦ãã ã•ã„

_æ³¨_ï¼š `for` ã®æ¡ä»¶ã®æ¨ªã« `(` `)` ã®ã‹ã£ã“ã‚’ã¤ã‘ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚å®Ÿéš›ã«ã¯ä»˜ã‘ã‚‹ã¨ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ã‚¨ãƒ©ãƒ¼ã«ãªã‚Šã¾ã™ã€‚è©¦ã—ã¦ã¿ã¦ãã ã•ã„ã€‚

* ãƒ«ãƒ¼ãƒ— ï¼ˆç¶šãï¼‰

ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³ã®ç·´ç¿’ã‚’ã—ã¾ã—ã‚‡ã†ã€‚ã“ã‚Œã¯ä»–ã®è¨€èªã ã¨ `while` ãƒ«ãƒ¼ãƒ—ã‚’ä½¿ã†å ´æ‰€ã«ãªã‚Šã¾ã™ã€‚

.play -edit src/loops/loops2/main.go /START OMIT/,/END OMIT/

ã“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ `10` ã‹ã‚‰ `1` ã¾ã§ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³ã—ã¾ã™ãŒã€ `7` ã‹ã‚‰ `3` ã¾ã§ã‚«ã‚¦ãƒ³ãƒˆã™ã‚‹ã‚ˆã†ã«ã—ã¦ãã ã•ã„ã€‚

- ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ç·¨é›†ã—ã€ `7` ã‹ã‚‰ `3` ã¾ã§ã®æ•°å€¤ã ã‘ã‚’å‡ºåŠ›ã™ã‚‹ã‚ˆã†ã«ã—ã¦ãã ã•ã„ã€‚
- *Run* ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã€æ­£ã—ã„ç­”ãˆã® `7`, `6`, `5`, `4`, `3` ãŒå‡ºåŠ›ã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºã‹ã‚ã¦ãã ã•ã„

_æ³¨_ï¼š ã“ã® `for` ãƒ«ãƒ¼ãƒ—ã¯ _æ¡ä»¶_ ã ã‘ãŒã‚ã‚Šã¾ã™ã€‚ _åˆæœŸåŒ–_ ã‚„ _äº‹å¾Œå‡¦ç†_ ã¯ãªã„ãŸã‚ã€ã‚»ãƒŸã‚³ãƒ­ãƒ³ `;` ã¯çœç•¥ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

* æ¡ä»¶æ–‡

Goã«ã¯2ã¤ã®æ¡ä»¶æ–‡ã€ `if` ã¨ `switch` ãŒã‚ã‚Šã¾ã™ã€‚

`if` ã¯ _æ¡ä»¶_ ã«ã‚‚ã¨ã¥ãã€2ã¤ã®é¸æŠè‚¢ã‹ã‚‰é¸ã¶ãŸã‚ã«ä½¿ã‚ã‚Œã¾ã™ã€‚

 if v > 0 {
         println("vã¯0ã‚ˆã‚Šå¤§ãã„")
 } else {
         println("vã¯0ã‚ˆã‚Šå°ã•ã„ã‹åŒã˜")
 }

å ´åˆã«ã‚ˆã£ã¦ã¯ `else` ãƒ–ãƒ­ãƒƒã‚¯ã¯çœç•¥ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã‚Œã¯ãƒ¡ã‚½ãƒƒãƒ‰ãƒ»é–¢æ•°ã®å‰ææ¡ä»¶ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹éš›ã«ã‚ˆãä½¿ã‚ã‚Œã¾ã™ã€‚

 if v == 0 {
         // ä½•ã‚‚ã—ãªã„
         return
 }
 // vã‚’å‡¦ç†ã™ã‚‹

* if

å‰ã®å¶æ•°ã® `for` ãƒ«ãƒ¼ãƒ—ã®ä¾‹ã‚’ã‚‚ã†ä¸€åº¦è¦‹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

.play -edit src/conditionals/conditionals1/main.go /START OMIT/,/END OMIT/

ã“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ `1` ã‹ã‚‰ `10` ã¾ã§æ•°ãˆã¾ã™ã€‚ _å¶æ•°_ ã ã‘ã‚’å‡ºåŠ›ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã‹ã€‚

- `if`i%2`==`0`{` ã¨ `}` ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚’å–ã‚Šã€ `1` ã‹ã‚‰ `10` ã¾ã§ã®å¶æ•°ã ã‘ã‚’å‡ºåŠ›ã™ã‚‹ã‚ˆã†ã«ã—ã¦ãã ã•ã„
- *Run* ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã€æ­£ã—ã„ç­”ãˆã® `2`, `4`, `6`, `8`, `10` ãŒå‡ºåŠ›ã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºã‹ã‚ã¦ãã ã•ã„

_æ³¨_ï¼š  `%` ã¯Goã§ã® _å‰°ä½™_ ã®æ¼”ç®—å­ã§ã™ã€‚å…¨ã¦ã®å¶æ•°ã¯å®Œå…¨ã«2ã§å‰²ã‚Šãã‚Œã€å‰°ä½™ï¼ˆã¾ãŸã¯ä½™ã‚Šï¼‰ã¯0ã«ãªã‚Šã¾ã™ã€‚

* continue

Javaã®ã‚ˆã†ãªè¨€èªã¨é•ã„ã€Goã§ã® `if` æ–‡ã¯ã—ã°ã—ã° _ã‚¬ãƒ¼ãƒ‰ç¯€_ ã¨ã—ã¦ä½¿ã‚ã‚Œã¾ã™ã€‚

å…¨ã¦ãŒçœŸã®ã¨ãã€ã‚³ãƒ¼ãƒ‰ã¯ãƒšãƒ¼ã‚¸ã®ä¸Šã‹ã‚‰ä¸‹ã¸ã¨èª­ã¾ã‚Œã¾ã™ã€‚

å‰ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€ãƒ«ãƒ¼ãƒ—ã®å†…å®¹ã‚’ã‚¹ã‚­ãƒƒãƒ—ã™ã‚‹ `continue` ã¨ã„ã†æ–°ã—ã„æ–‡ã‚’ä½¿ã£ã¦æ›¸ãç›´ã™ã“ã¨ãŒã§ãã¾ã™ã€‚

.play -edit src/conditionals/conditionals2/main.go /START OMIT/,/END OMIT/

- `if`i%1`==`1`{`, `continue`, `}` ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚’å–ã£ã¦ãã ã•ã„
- *Run* ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã€æ­£ã—ã„ç­”ãˆã® `2`, `4`, `6`, `8`, `10` ãŒå‡ºåŠ›ã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºã‹ã‚ã¦ãã ã•ã„

* break

ã“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ç„¡é™ãƒ«ãƒ¼ãƒ—ã«ãªã‚Šã¾ã™ã€‚ `for` ãƒ«ãƒ¼ãƒ—å†…ã« _æ¡ä»¶å¼_ ãŒã‚ã‚Šã¾ã›ã‚“ã€‚

ç¾åœ¨ã®ãƒ«ãƒ¼ãƒ—ã‹ã‚‰æŠœã‘ã‚‹ `break` æ–‡ã‚’ä½¿ã£ã¦ã€ä¿®æ­£ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

.play -edit src/conditionals/conditionals3/main.go /START OMIT/,/END OMIT/

- `if`i`>`10`{`, `break`, `}` ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚’å–ã£ã¦ãã ã•ã„
- *Run* ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã€æ­£ã—ã„ç­”ãˆã® `2`, `4`, `6`, `8`, `10` ãŒå‡ºåŠ›ã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºã‹ã‚ã¦ãã ã•ã„

* å‹æ¨è«–

ã“ã‚Œã¾ã§ã®ä¾‹ã§ã¯å‹ã«ã¤ã„ã¦ã®è©±é¡Œã¯é¿ã‘ã¦ãã¾ã—ãŸã€‚ã“ã‚Œã¯GoãŒ _å‹æ¨è«–_ ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ãŸã‚ã§ã™ã€‚

å‹æ¨è«–ã¯ã€å®£è¨€æ™‚ã«å¤‰æ•°ã®å‹ã‚’çœç•¥ã§ãã¾ã™ã€‚

ä¾‹ãˆã°ã€

 var i = 7

Goã¯ `i` ãŒå®£è¨€ã•ã‚Œã€ `7` ã¨ã„ã†å€¤ã§åˆæœŸåŒ–ã•ã‚Œã‚‹ã“ã¨ã‚’çŸ¥ã£ã¦ã„ã‚‹ãŸã‚ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯ `i` ã®å‹ã‚’ `int` ã ã¨æ¨æ¸¬ã—ã¾ã™ã€‚

ã—ã‹ã—ã€ã‚‚ã—ã‚‚

 var s = "seven"

ã¨ã™ã‚‹ã¨ã€Goã¯ `s` ãŒ _æ–‡å­—åˆ—_ ã® `"seven"` ã§åˆæœŸåŒ–ã•ã‚Œã‚‹ã“ã¨ã‚’çŸ¥ã£ã¦ãŠã‚Šã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯ `s` ã®å‹ã‚’ `string` ã¨æ¨æ¸¬ã—ã¾ã™ã€‚

* æ˜ç¤ºçš„ãªå‹å®£è¨€

å ´åˆã«ã‚ˆã£ã¦ã¯ã€Goã«ç‰¹å®šã®å‹ã‚’ä½¿ã†ã‚ˆã†ã«æŒ‡ç¤ºã—ãŸã„ã¨ããŒã‚ã‚‹ã§ã—ã‚‡ã†ã€‚

å¤‰æ•°ã‚’å®£è¨€ã™ã‚‹ã¨ãã«ã“ã†ã—ã¾ã™ã€‚

 var i int = 4
 var s string = "ãŠã¯ã‚ˆã†ã”ã–ã„ã¾ã™"

ã“ã‚Œã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã«å¯¾ã—ã¦æ˜ç¤ºçš„ã« `i` ã‚’ `7` ã® `int` ã€ `s` ã¯ `"ãŠã¯ã‚ˆã†ã”ã–ã„ã¾ã™"` ã¨ã„ã†å€¤ã® `string` ã ã¨å®£è¨€ã—ã¦ã„ã¾ã™ã€‚

æ¬¡ã®ã‚¹ãƒ©ã‚¤ãƒ‰ã§GoãŒã‚µãƒãƒ¼ãƒˆã™ã‚‹ç¨®é¡ã®å‹ã«ã¤ã„ã¦èª¬æ˜ã—ã¾ã™ã€‚

* å‹

Goã¯Javaã‚„Cã€C++ã‚„Pythonã®ã‚ˆã†ã«å¼·ã„å‹ä»˜ã‘ã®è¨€èªã§ã™ã€‚Goã¯9ç¨®é¡ã®å‹ãŒã‚ã‚Šã¾ã™ã€‚ãã‚Œã¯ã€

- æ–‡å­—åˆ—: `string`
- ç¬¦å·ä»˜ãæ•´æ•°: `int8`, `int16`, `int32`, `int64`
- ç¬¦å·ãªã—æ•´æ•°: `uint8`, `uint6`, `uint32`, `uint64`
- ã‚¨ã‚¤ãƒªã‚¢ã‚¹: `byte`, `rune`, `int`, `uint`
- ãƒ–ãƒ¼ãƒªã‚¢ãƒ³: `bool`
- IEEE æµ®å‹•å°æ•°ç‚¹æ•°: `float32`, `float64`
- è¤‡ç´ æ•°å‹: `complex64`, `complex128`
- è¤‡åˆå‹: `array`, `slice`, `map`, `struct`
- ãƒã‚¤ãƒ³ã‚¿å‹: `*int`, `*bytes.Buffer`

* æ–‡å­—åˆ—å‹

æ–‡å­—åˆ—ã¯Goã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã‚‚ã£ã¨ã‚‚ä¸€èˆ¬çš„ãªå‹ã§ã™ã€‚

æ–‡å­—åˆ—å‹ã¯ä»–ã®è¨€èªã§æœŸå¾…ã™ã‚‹é€šã‚Šã«å‹•ä½œã—ã¾ã™ã€‚

.play -edit src/strings/strings1/main.go /START OMIT/,/END OMIT/

æ–‡å­—åˆ—ã¯ `+` æ¼”ç®—å­ã§é€£çµã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

- *Run* ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒçµæœã‚’è¦‹ã¦ã¿ã¦ãã ã•ã„

_æ³¨_ï¼š Goã§ã®ç©ºæ–‡å­—ã¯ `""` ã§ã™ã€‚ `null` ã‚„ `nil` ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚

* æ•´æ•°å‹

æ•´æ•°å‹ã¯ï¼’ç•ªç›®ã«ä¸€èˆ¬çš„ã§ã™ã€‚

æ•´æ•°å‹ã«ã¯ï¼’ã¤ã®ç¨®é¡ãŒã‚ã‚Šã¾ã™ã€‚ _ç¬¦å·ä»˜ã_ ã¨ _ç¬¦å·ãªã—_ ã§ã™ã€‚

æ•´æ•°å‹ã«ã¯ã¾ãŸã€ãƒ“ãƒƒãƒˆæ•°ã§è¡¨ç¾ã•ã‚Œã‚‹ã„ãã¤ã‹ã®å¤§ãã•ãŒã‚ã‚Šã¾ã™ã€‚

- ç¬¦å·ä»˜ãæ•´æ•°: `int8`, `int16`, `int32`, `int64`.
- ç¬¦å·ãªã—æ•´æ•°: `uint8`, `uint16`, `uint32`, `uint64`.

Goã¯ï¼’ã¤ã®æ•´æ•°å‹ãŒã‚ã‚Šã€

- `int`, ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã«å¿œã˜ã¦ `int32` ã‹ `int64` ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã«ãªã‚Šã¾ã™
- `uint`, ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã«å¿œã˜ã¦ `uint32` ã‹ `uint64` ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã«ãªã‚Šã¾ã™

ã“ã®å¤§ãã•ã¯Goãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ãƒ“ãƒ«ãƒ‰ã—ãŸãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã«ã‚ˆã£ã¦ç•°ãªã‚Šã¾ã™ã€‚

* æ•´æ•°å‹ ï¼ˆç¶šãï¼‰

ãªãœGoã¯ã“ã‚“ãªå¤šãã®æ•´æ•°å‹ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ

ç•°ãªã‚‹ _ã‚µã‚¤ã‚º_ ã®æ•´æ•°å‹ã¯ç•°ãªã‚‹ç¯„å›²ã®æ•°ã«å¯¾å¿œã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

.play -edit src/types/types1/main.go /START OMIT/,/END OMIT/

ã“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯2ã¤ã®å‹ã‚¨ãƒ©ãƒ¼ã‚’å«ã‚“ã§ã„ã¾ã™ã€‚

- *Run* ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ã€2ã¤ã®å‹ã‚¨ãƒ©ãƒ¼ã‚’ç™ºè¦‹ã—ã¦ãã ã•ã„
- å®£è¨€ã•ã‚ŒãŸ `x` ã¨ `y` ã‚’å¤‰æ›´ã—ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ä¿®æ­£ã—ã¦ãã ã•ã„ã€‚
- *Run* ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã€æ­£ã—ã„ç­”ãˆã® `400`, `-7` ãŒå‡ºåŠ›ã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºã‹ã‚ã¦ãã ã•ã„

* é–¢æ•°

ä»Šåº¦ã¯ _é–¢æ•°_ ã«ã¤ã„ã¦ãŠè©±ã—ã¾ã—ã‚‡ã†ã€‚

å…¨ã¦ã®Goã¯é–¢æ•°ã§æ§‹æˆã•ã‚Œã¦ã„ã¾ã™ã€‚å®Ÿéš›ã«ã€ã‚ãªãŸã¯ã™ã¹ã¦é–¢æ•°ã‚’è¨˜è¿°ã—ã¦ãã¾ã—ãŸã€‚

.play -edit src/functions/functions1/main.go /START OMIT/,/END OMIT/

ã“ã‚Œã¯å‰ã®ä¾‹ã¨åŒã˜ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã€å‰ã¯éš ã•ã‚Œã¦ã„ãŸ _é–¢æ•°å®£è¨€_ ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚

- å…¨ã¦ã®Goãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ `main` ã¨å‘¼ã°ã‚Œã‚‹é–¢æ•°ã§å§‹ã¾ã‚Šã€ã“ã‚Œã‚’ _ãƒ¡ã‚¤ãƒ³é–¢æ•°_ ã¨å‘¼ã³ã¾ã™

* func

`func` å®£è¨€ã§ã€ç‹¬è‡ªã®é–¢æ•°ã‚’å®£è¨€ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
é–¢æ•°åã¯ `const` ã‚„ `var` åŒæ§˜ã«ã€æœ‰åŠ¹ãªè­˜åˆ¥å­ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚

.play -edit src/functions/functions2/main.go /START OMIT/,/END OMIT/

ã“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ï¼’ã¤ã®é–¢æ•° `main` ã¨ `hello` ã‚’å®£è¨€ã—ã¦ã„ã¾ã™ã€‚

- `func`hello` ã® `println("ã“ã‚“ã«ã¡ã¯")` æ–‡ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚’å¤–ã—ã¦ãã ã•ã„
- *Run* ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã€ ã“ã‚“ã«ã¡ã¯ ãŒ3å›å‡ºåŠ›ã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºã‹ã‚ã¦ãã ã•ã„

_æ³¨_ï¼š `println` ã¯ _çµ„ã¿è¾¼ã¿_ ã®é–¢æ•°ã§ã€å®£è¨€ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã›ã‚“ã€‚

* é–¢æ•°ã®å¼•æ•°

é–¢æ•°ã‚’ä¾¿åˆ©ã«ã™ã‚‹ãŸã‚ã«ã¯ã€é–¢æ•°ã¸å¼•æ•°ã‚’æ¸¡ã™ã“ã¨ãŒå¿…è¦ã«ãªã‚‹ã§ã—ã‚‡ã†ã€‚

To pass an argument to a function, the type of the argument and the type of the function's _formal_parameter_ must be the same.

.play -edit src/functions/functions3/main.go /START OMIT/,/END OMIT/

In this program the type of the argument passed to `hello` does not match the type of the `name` parameter.

- Fix the declaration of `hello` so that the type of the parameter matches the type of the argument provided.
- Press *Run* and check the program compiles and prints `ã“ã‚“ã«ã¡ã¯`David`.

* Packages

A package is the unit in which software is shared and reused in Go. All Go code is arranged into packages.

Each source file in a package must begin with the same `package` declaration.

A package's name must be a valid identifier, just like `const`, `var`, and `func`.

.play -edit src/packages/packages1/main.go

This is the same example as the previous slide, revealing the `package` declaration.

`package`main` is the name of the package which contains the entry point to your program, `func`main`.

* main packages

This program has the wrong `package` declaration.

.play -edit src/packages/packages2/main.go

- Press *Run* and observe the compile error.
- Change the `package` declaration to make the program compile.
- Press *Run* to check that program prints its greeting.

* Import

The final declaration we'll cover in this section is the _import_ declaration.

The `import` declaration allows you to use code from other _packages_ into your package.

When you `import` a package, the _public_ types, functions, variables, types, and constants, are available with a prefix of the package's name.

 time.Now	// denotes the Now function in package time

Note that

 import "fmt"
 import "time"

and

 import (
         "fmt"
         "time"
 )

both import the `fmt` and `time` packages. The syntax is different, but they are equivalent.

* Import (cont.)

The `import` declaration must appear _after_ the `package` declaration, but before any `type`, `const`, `var`, or `func` declarations.

.play -edit src/imports/imports1/main.go

This program does not compile as the `import` declaration is in the wrong place.

- Move the `var`now`=`time.Now()` declaration _below_ the `import` declaration.
- Press *Run* to check that program prints the current time.

* Import (cont.)

Packages contain both _public_ and _private_ symbols. We also call these _exported_ and _not_exported_, respectively.

.play -edit src/imports/imports2/main.go

This program does not compile as it refers to two _private_ symbols.

- Fix the program by using the correct case for `Println` and `Time`.
- Press *Run* to check that program prints the current time.

_note_: If you are running this slide from [[https://go-talks.golang.org/][gotalks.golang.org]], the time may be reported as `2009-11-10`23:00:00`+0000`UTC`. This is a technical limitation.

* fmt package

Do you remember this program?

.play -edit src/imports/imports3/main.go

Here it is again, showing the `func`, `package` and `import` declarations making it a complete Go program.

This program also uses the `Println` function from the `fmt` package, which is more capable than the built in `println` function.

- Press *Run* to see how `fmt.Println` prints this output.

* Recap

Now you know the basics of Go!

You've learnt:

- How to declare constants and variables
- How to write `for` loops and use `if`.
- How types work.
- How to write your own functions.
- How packages and `import` statements work.

Time for a quick break!

* Advanced Syntax

* Advanced Syntax

This section builds on the previous by exploring each of the things we learnt in a little more detail.

In this section we'll use the Go Playground, a simple online code editor to perform our exercises.

* Coding style

All Go code is formatted according to a single style guide which is enforced with a tool called `gofmt`

Having one single style that all Go code is formatted in improves readability and avoids the time wasted arguing about code formatting.

"Gofmt's style is no one's favorite, yet gofmt is everyone's favorite."
.caption [[https://go-proverbs.github.io/][Go Proverb]].

The Go playground can format your code according to the canonical Go style.

- Follow [[https://play.golang.org/p/0Hz57BQdTA][this link]] and press the *Format* button to see this in action.

* Zero value

In previous examples we've written code like this

 var name = "go"
 var counter = 1

Which both _declares_ and _initalises_ the variables `counter` and `name` respectively. What happens if we have code like this?

.code src/zerovalue/zerovalue1/main.go

What will this print?

- Follow [[https://play.golang.org/p/jioUB0t_LW][this link]] and press the *Run* button to see this in action.

* Zero value (cont.)

In Go, there is no unitialised memory. The Go runtime will always ensure that the memory allocated for each variable is initalised before use.

If we write something like

 var name string
 var counter int

Then the memory assigned to the variables `name` and `counter` will be zeroed, as we have not provided an _initaliser_.

- The value of `name` will be `""` because that is the value of a string with zero length.
- The value of `counter` will be zero, because that is the value of an `int` if we wrote `0` to its memory location.

* Zero value (cont.)

Every type in Go has an associated _zero_value_. The value of that variable if we wrote zeros to its memory.

- The zero value for integer types: `int`, `int8`, `uint`, `uint64`, etc, is `0`.
- The zero value for floating point types: `float32`, `float64`, `complex128`, etc, is `0.0`.
- The zero value for arrays is the zero value for each element, ie. `[3]int` is `0`, `0`, `0`.
- The zero value for slices is `nil`.
- The zero value for structs is the zero value for each field.

* Equality

As Go is a strongly typed language, for two variables to be equal, both their _type_and_their_value_ must be equal.

Trying to compare two variables of _different_ types is detected at runtime.

.code src/equality/equality1/main.go

- Follow [[https://play.golang.org/p/LwiJm2xuXK][this link]] and press the *Run* button.
- Fix the program by declaring `x` and `y` to be the _same_ type.
- Press the *Run* button and confirm the program now prints `true`.

* Type conversions

Sometimes you have variables of different integer types, you can _convert_ from one type to another using a conversion _expression_.

The expression `T(v)` converts the value `v` to the type `T`.

.code -edit src/types/types2/main.go

In this example the assignment of `y`=`x` fails because `x` and `y` are different integer types.

- Follow [[https://play.golang.org/p/wvG41C0lH4][this link]] and press the *Run* button.
- Fix the program by _converting_ `x` to an `int` with `int(x)`.
- Press the *Run* button and confirm the program now prints `700`.

* Type conversions (cont.)

If you have variables of different _widths_, you can _convert_ from one type to another.

.code -edit src/types/types3/main.go

- Follow [[https://play.golang.org/p/l4Q48pWAla][this link]] and press the *Run* button.
- Fix the program by _converting_ `x` to an `int64` with `int64(x)`.
- Press the *Run* button and confirm the program now prints `32000`.

* Type conversions (cont.)

We can do the opposite and convert a wider type to a narrower type.

.code -edit src/types/types4/main.go

- Follow [[https://play.golang.org/p/NbNwRjbmRu][this link]] and press the *Run* button. Does it print the answer you expected?
- Fix the program by _declaring_ `y` as an `int32`.
- Press the *Run* button and confirm the program now prints `64000`.

* Integer overflow

Whenever you declare a variable in Go, you have to choose how many bits of memory it will consume.

When you convert a variable with a _smaller_ number of bits to a variable with a larger number of bits, this is fine, because they all fit.

When you convert a variable with a _larger_ number of bits to a variable with a smaller number of bits there is a risk of truncation, because there are less bits available to represent your number.

- Follow [[https://play.golang.org/p/NbNwRjbmRu][this link]] and press the *Run* button. Does it print the answer you expected?
- Fix the program by reducing the value of `x`. Hint: the value needs to be less than 33,000.
- Press the *Run* button and confirm the program now prints `y` correctly.

* Short declaration syntax

As you've probably noticed, Go has several ways to declare variables. All three of these are the same

 var x = 0
 var x int = 0
 var x int

If you've come from a language like Ruby or Python, you're probably wondering if this very common operation can be made more concise. Indeed it can.

 x := 0

This is what we call a _short_declaration_, which is the same as

 var x int = 0

Short declaration is very common in Go programs, you'll see it everywhere, so let's do some exercises to familarise you with its use.

* Short declaration syntax (cont.)

A common use of the short declaration syntax is in `for` loops. Consider this program

 var i int
 for i = 1; i < 11; i++ {
         fmt.Println(i)
 }

This can be also written as

 for i := 1; i < 11; i++ {
         fmt.Println(i)
 }

[[https://play.golang.org/p/3Vl75w72JO][This program]] contains two `var` declarations and two `for` loops.

- Follow [[https://play.golang.org/p/3Vl75w72JO][this link]] and press the *Run* button.
- Rewrite the program using the short declaration syntax; there should be no `var` declarations, only `:=`.

* Slices

The next kind of type to discuss is the _Slice_.

A slice is an ordered collection of values of a _single_ type.

The syntax for declaring a slice variable is very similar to declaring a _scalar_ variable.

 var i int      // an int called i
 var j []int    // a slice of ints called j

In this example,

- `i` is a variable of type `int`.
- `j` is a variable of type `[]int`, that is, a slice of `int`.

Slices are very important in Go programs, so we'll spend a bit of time discussing them.

_note_: A slice is _not_ an array. Go also supports arrays, but you'll see later than they aren't very common, or very easy to use, so we won't discuss them at the moment.

* How large is a slice?

If I declare a slice, `[]int`, how many items can it hold?

The _zero_value_ of a slice is empty, that is, it has a _length_ of zero; it can hold 0 items.

.code -edit src/slices/slices1/main.go

We can retrieve the length of a slice with the built-in `len` function.

- Follow [[https://play.golang.org/p/gZYvdE2zbT][this link]] and press the *Run* button.
- Did you guess the right answer?

* Making a slice

We can create a slice with space to hold items using the built-in `make` function.

.code -edit src/slices/slices2/main.go

In this example, on the first line `var i []int` declares `i` to be a slice of `int`.

On the second line, `i` is _assigned_ the result of `make([]int,`20)`.

- Follow [[https://play.golang.org/p/i_IWqjik6u][this link]] and press the *Run* button.
- Did `fmt.Println(len(i))` print the result you expected?

* Making a slice (cont.)

Because declaring a slice variable and initalising it with `make` is a common operation, it is common to see the _short_variable_declaration_ used to combine this operations.

.code -edit src/slices/slices3/main.go

This example declares `i` _and_ initalises it to be a slice of `int` with a length of 20.

- Follow [[https://play.golang.org/p/b92SJ0Gx9s][this link]] and press the *Run* button.
- Did `fmt.Println(len(i))` print the result you expected?

* Slice exercises

Let's do a quick exercise to familarise yourself with using slices.

.code -edit src/slices/slices4/main.go

- Follow [[https://play.golang.org/p/AJk1Jgp1iE][this link]] for instructions.
- Declare a variable called `i` which is a slice of 5 `int`.
- Declare a variable called `f` which is a slice of 9 `float64`.
- Declare a variable called `s` which is a slice of 4 `string`.
- Does your program print the expected result, `5`9`4`?

* Index expressions

To access, or assign, the contents of a slice element at index `i`, use the form `s[i]`.

Slices are zero indexed, so `s[0]` is the 1st element, `s[1]` is the second element, and so on.

When the _index_expression_ appears on the _left_hand_side_ of the equals operator, `=`

 s[7] = 20

We are assigning the number 20 to the 8'th element of the slice `s`.

When the _index_expression_ appears on the _right_hand_side_ of the equals operator, `=`

 x := s[7]

We are assigning the value at the 8th element of `s` to the variable `x`.

* Slice zero value

We saw earlier that the _zero_value_ of the slice

 var s []int

was and empty slice, a slice with length of zero.

What is the value of each of the elements of a newly created, with make, slice?

.play -edit src/slices/slices5/main.go

- Follow [[https://play.golang.org/p/kGh_C1l6KW][this link]] and press the *Run* button.
- Did the program print the result you expected?

* Slice initialisation

We want to create an `[]int` slice of the first 10 prime numbers, how could we do this?

One solution could be to create the slice and assign a value to each element in the slice.

.play -edit src/slices/slices6/main.go

* Slice initialisation (cont.)

Doing this manually is verbose and boring; how would you do this for the first 50 primes?

Go supports a method of assignment where we both _declare_ and _initalise_ the slice at once.

.play -edit src/slices/slices7/main.go

This is called the _composite_literal_ syntax.

- Follow [[https://play.golang.org/p/P-eBqzPCWh][this link]] and complete the exercise.

* append

So far we've been using slices with a known length. You can extend the contents of a slice with the built-in `append` function.

.play -edit src/slices/slices8/main.go

`append` increases the length of the slice to accommodate the new items, then returns a new slice value.

You can `append` multiple values in one statement, providing they are all the same type.

.link https://blog.golang.org/slices Further reading: Arrays, slices (and strings): The mechanics of 'append' (blog.golang.org)

* Subslices

What if we have a large slice, and want to refer to only a part of it.

We call this slicing a slice, or _subslicing_.

Subslicing looks similar to the _indexing_ operation we saw a few slide ago, except it refers to a range of slice indexes.

.play -edit src/slices/slices12/main.go

The expression `brothers[0:3]` evaluates to a slice of the 1st to 3rd Marx brother.

- Follow [[https://play.golang.org/p/d1-jl42aTF][this link]] and complete the exercise.

* Subslices (cont.)

An important thing to remember when slicing a slice, is that both slices refer to the _same_ underying data.

.play -edit src/slices/slices10/main.go

To create two independent slice values, you would use the `copy` function, which we'll discuss later.

* Bounds checking

Each slice has a length which is decided when it is made.

You can increase the length of the slice with the `append` function, and create a smaller slice from a larger one using the slice operator.

What happens if you accidentally exceed the bounds of the slice?

.play -edit src/slices/slices11/main.go

- Follow [[https://play.golang.org/p/mIWm0a1amp][this link]] and press the *Run* button.
- Comment out `fmt.Println(primes[-1])` and see what happens.

* Multiple assignment

Go allows you to perform multiple assignments and declarations in one statement.

For example, if we wanted to declare, `x`, `y`, and `z`, with the values `1`, `2`, and `3` respectively. We could write

 var x = 1
 var y = 2
 var z = 3

We can write the same thing like this

 var x, y, z = 1, 2, 3

- Follow [[https://play.golang.org/p/d2hDJQAfkt][this link]] for some examples of multiple declaration.

* Multiple return values

Multiple assignment is important to understand because you can return multiple values from a function.

 func f(i int)

This is a function declaration for `f` which takes one argument, an `int`.

 func g(i int, j int, k string) int

This is a function declaration for `g`, which takes three arguments, two `int` s and a `string`, and returns an `int`.

 func h(i, j int) (int, int, string)

This is a function declaration for `h`, which takes two arguments, two `ints`, and returns three values, two `int` s and a `string`.

* Multiple return values (cont.)

Your program must return the number of values specified in the function signature.

.play -edit src/functions/functions4/main.go

* Assigning multiple return values

When you call a function that returns multiple values, you must assign _all_ of them or _none_ of them.

 func f() (int, bool, string)

 func main() {
         a, b, c := f()
         fmt.Println(a, b, c)
 }

`f` returns three values, so we assign them to `a`, `b`, and `c` using the short declaration syntax.

If we wanted to use only the first and third values we can ignore the second by assigning it to the underscore variable, `_`.

 func main() {
         a, _, c := f()
         fmt.Println(a, c)
 }

* Maps

Go has a built in Hash Map type, called a `map`.

Maps map values of key type K to values of type V

 var m map[string]int

Just like making a slice, making a map is accomplished with the `make` built-in.

.play -edit src/maps/maps1/main.go

* Inserting values into a map

Inserting a value into a map looks similar to assigning a value to a slice element.

.play -edit src/maps/maps2/main.go

If an entry already exits with that key, it will be overwritten.

- Follow [[https://play.golang.org/p/a-V5I0nZ5l][this link]] and complete the exercise.

_note_: maps are always _unordered_.

* Compact literal initalisation

Just like slices, maps support compact literal initalisation, which declares and initalises the map.

.play -edit src/maps/maps3/main.go

* Retrieving a values from a map

Just like a slice, you can retrieve the value stored in a map with the syntax `m[key]`.

If it is present the value will be returned, if not the _zero_value_ will be returned.

.play -edit src/maps/maps4/main.go

* Checking if a map value exists

In the previous slide we saw that `moons["Neptune"]` returned `0`.

How can we tell if Neptune actually has no moons, or if `0` was returned because there is no entry for Neptune?

Map look ups support a second syntax.

.play -edit src/maps/maps5/main.go

* Deleting a value from a map

To delete a value from a map, you use the built in `delete` function.

.play -edit src/maps/maps6/main.go

* Iterating over a map

If we wanted to print out all the values in a map we can use a form of the `for` syntax which is known as `range`.

.play -edit src/range/range1/main.go

`range` loops over each entry in the map, assigning the map key to `name`, and the map value to `pop`.

* Range over slices

We say previously that `for`range` works with maps, it also works with slices.

.play -edit src/range/range2/main.go

- Follow [[https://play.golang.org/p/AmQW-OrPC1][this link]] and complete the exercise.
- If you cannot figure it out, don't worry, there is an answer on the next slide.

* Switch

If you completed the previous exercise you may have written something like this

.play -edit src/range/range2a/main.go /START OMIT/,/END OMIT/

Heavily nested `if`else`if` blocks are discouraged in Go.

Instead we can use the other condition statement, `switch`.

* Switch (cont.)

`switch` can be used

.play -edit src/switch/switch1/main.go /START OMIT/,/END OMIT/

* fmt

Let's conclude this section by talking about the fmt package.

`fmt` standard for formatted printing; the name is inherited from Go's Plan 9 legacy.

We've use `fmt.Println` a lot up to this point, but the `fmt` package has many other useful functions.

We'll focus on `fmt.Printf`, the `f` stands for _formatted_output_.

Here is an example.

.play -edit src/fmt/fmt1/main.go /START OMIT/,/END OMIT/

- Follow [[https://play.golang.org/p/UuzPWcwDrE][this link]] to experiment.

* Formatting verbs

If you're used to languages like Python or C, you're probably used to the idea of _formatting_verbs_.

The `fmt` package supports a large number of formatting verbs and modifiers. In the previous example you saw `%s` and `%d`, for `string` and `int` respectively.

The `fmt` package is smart enough to spot when you use the wrong formatting verb, or don't provide enough arguments to `fmt.Printf`.

.play -edit src/fmt/fmt2/main.go /START OMIT/,/END OMIT/

* Formatting verbs (cont.)

Having to choose the correct verb that matches the type of the value you want to print is boring.

To make it easier to use `fmt.Printf` in the simple case, you can use the `%v` verb, which know how to print _any_ value.

.play -edit src/fmt/fmt3/main.go /START OMIT/,/END OMIT/

- Follow [[https://play.golang.org/p/B-E7JOJ1Db][this link]] to experiment with a few more formatting verbs.

* Recap

Now you know most of Go!

You've learnt:

- How Go code is formatted.
- How what the zero value is and how it works.
- Equality and type conversions
- The short declaration syntax
- Multiple assignment.
- How slices work.
- How maps work.
- How the `fmt` package works.

Time for lunch!

* Development environment and tooling

* Development environment and tooling

This section focuses on the developer experience

- Installing Go.
- Setting up a `$GOPATH` workspace.
- Introduction to the `go` command.
- Writing unit tests with the go test command.

* Installing Go

The next few slides give examples of how to install Go on various systems.

The official installation documentation is here:

.link https://golang.org/doc/install

The current version of Go is 1.7.4.

- New minor releases, Go 1.8, Go 1.9, etc, ship twice a year.
- Historically 2â€“4 bug fix or security releases occur during each six month period.

* Installing Go on OS X

Installing Go on OS X (also known as `darwin`) can be accomplished with

*Max OS Installer*

The Go project provides an `.pkg` installer, use:

.link https://storage.googleapis.com/golang/go1.7.4.darwin-amd64.pkg

*Homebrew*

If you use Homebrew to manage third party software on your Mac, use:

 brew install golang

*MacPorts*

If you use MacPorts to manage third party software on your Mac, use:

 sudo port install go

* Installing Go on Windows

*MSI*Installer*

The Go project provides a `.msi` installer for 32bit and 64bit Windows, use:

.link https://storage.googleapis.com/golang/go1.7.4.windows-amd64.msi Windows 64bit MSI installer
.link https://storage.googleapis.com/golang/go1.7.4.windows-386.msi Windows 32bit MSI installer

*.zip*file*

The Go project provides a `.zip` file of the Go compiler and standard library, use:

.link https://storage.googleapis.com/golang/go1.7.4.windows-amd64.zip Windows 64bit zip file
.link https://storage.googleapis.com/golang/go1.7.4.windows-386.zip Windows 32bit zip file

Unzip the zip file and place it at `C:\Go`.

* Installing Go on Linux

Depending on your Linux distribution they may have an up to date version of Go, but this is rare.

The most reliable way to install the latest version of Go is to untar

.link https://storage.googleapis.com/golang/go1.7.4.linux-amd64.tar.gz

to the directory

 /usr/local

and add

 /usr/local/go/bin

to your `$PATH`.

 echo "export PATH=$PATH:/usr/local/go/bin" >> ~/.bash_profile

* Go tool

Your Go installation comes with a tool we call the `go` tool, because that's its name.

The `go` tool can

- compile your programs
- run your tests
- display documentation for a package
- fetch packages from the internet.

* $GOPATH

The `go` tool works inside a workspace where _all_ your Go source code is stored.

All the source code for this workshop is included with this repository.

You can set `$GOPATH` to be the base directory where you checked out this repository. eg.

 % export GOPATH=$HOME/introduction-to-go

Using a workspace allows you to import code from other packages with a fixed name. eg.

 import "github.com/pkg/profile"

Will import the code for the `profile` package stored in

 $GOPATH/src/github.com/pkg/profile

* go build

Go is a compiled language, so the usual work flow is

- Edit code
- `go`build`
- Run program

Let's try building a Go program

- `cd`$GOPATH/src/helloworld`
- Read the source for `hello.go`
- Build the source with `go`build`
- Run the program `./helloworld`

* What time is it (exercise)

Let's write a clock, a program that prints out the current time

- `cd`$GOPATH/src/whattimeisit`
- edit `main.go` and finish the program (if you get stuck the answer is in `answer.go`)
- Build the program with, `go`build` (if you make an error, go back and edit `main.go`)
- Run your program `./whattimeisit`, it should print something like this

 The current time is 2016-12-05 12:33:18.222821474 +0900 JST

* Testing

I wanted to spend some time on testing because for the rest of the day we'll be using tests to complete code katas.

The testing package can also contain benchmark functions and examples, which show up in godoc.

You should include tests for each package that you write.

The `testing` package is ideal for _unit_tests_. It's _ok_ for functional tests, but not really suitable for complex integration tests.

* go test

`go`test` is the unit testing framework built into the Go standard library. It lives in the `testing` package.

Tests live in `_test.go` files, eg. the `strings` package has these files:

- `strings.go` functions to manipulate UTF-8 encoded strings.
- `strings_test.go` tests for the `strings` package.

Each test is a function in the form

 func TestNameOfTest(t *testing.T) { ... }

- `NameOfTest` is the name of your test, it _must_ start with an upper case letter.
- Test functions take a `testing.T` value, which provides helpers like `t.Error` and `t.Fail`.

* Writing tests

Let's write some tests using our own version of the strings package, called `simplestrings`.

- The code for this exercise is in `$GOPATH/src/simplestrings/`
- Read the source code for `simplestrings.go`

Together we'll write some tests for the functions in our `simplestrings` package.

We'll use the test coverage (see next slide) tool to check our work.

* Test coverage

`go`test` can report coverage

 go test -coverprofile=cover.out

This produces a coverage file, `cover.out`

- `go`tool`cover`-func=cover.out` will print the coverage report
- `go`tool`cover`-html=cover.out` will open the report in a browser

_Protip_: I use these little shell functions to make this easier

 cover () {
   t=$(mktemp -t cover)
   go test $COVERFLAGS -coverprofile=$t $@ && go tool cover -func=$t && unlink $t
 }

 cover-web() {
   t=$(mktemp -t cover)
   go test $COVERFLAGS -coverprofile=$t $@ && go tool cover -html=$t && unlink $t
 }

* The standard library

Go ships with a rich standard library of packages. This includes

- file input / output
- string handling
- compression
- encoding and decoding of JSON and XML
- network handling
- HTTP client and server

* Katas

For the rest of the day let's practice writing Go code together.

The Ruby community have a tradition of _code_katas_, small exercises to make the test pass.

As we work through the katas, we'll visit some more of the Go standard library.

* String formatting

As a warm up, let's do a small kata together.

The code for this kata is in `$GOPATH/src/katas/sprintf`

If you get stuck, the answers are in `$GOPATH/src/katas/sprintf/answers_test.go`.

* Structs

So far we've discussed two kinds of types; _primitive_ types and _slice_ types.

Go supports what we call _compound_ types, that is, types that are _composed_ of other types.

These are called _struct_ (for _structure_) types. We declare a struct like this:

 type Point struct {
          X int
          Y int
 }

`Point` is a position in two dimensional space, it has two fields, `X` and `Y`.

- Complete the kata in `$GOPATH/src/katas/points` by making all the tests pass.

* Methods

To this point we've talked about functions, which belong to a package

 // Max returns the larger of a or b.
 func Max(a, b int) int

In Go, you can attach a function to a type that you declare, this is called a _method_.

 type Point struct { X, Y int }

 func (p Point) String() string {
          return fmt.Sprintf("point: x=%d, y=%d", p.X, p.Y)
 }

Any type that implements a `String()`string` method will be used by the `fmt` package when it prints the value.

- Complete the kata in `$GOPATH/src/katas/methods` by making all the tests pass.

* Pointers

Whenever you pass a value to a function or method, the value is _copied_.

In Go, the method's receiver is also a value, so it's copied when you call a method.

.play -edit src/pointers/pointers1.go /START OMIT/,/END OMIT/

- Complete the kata in `$GOPATH/src/katas/pointers` by making the test pass.

* Interfaces

Go is an object oriented language; we have methods on types, but Go does not support inheritance or sub-classes.

Go supports polymorphism, _has_a_ (not _is_a_) with _interfaces_.

An interface declaration looks like this:

 type Reader interface {
          Read(buf []byte) (int, error)
 }

This is the [[https://golang.org/pkg/io/#Reader][`io.Reader`]] interface declaration from the [[https://golang.org/pkg/io/][`io`]] package.

Go does not have an _implements_ keyword, any type with the correct set of methods _is_ an implementation of the interface.

* Reading input

This kata asks you to write a function that reads lines from an io.Reader and returns a string containing all the lines read.

The code for this kata is in `$GOPATH/src/katas/input`

* Readers

To familarise you with the `io.Reader` implementations available in the `io` package, this kata is all about Readers.

- Complete the kata in `$GOPATH/src/katas/readers` by making the test pass.
- If you get stuck, consult the documentation in the [[https://golang.org/pkg/io/][`io`]] package.

* Error handling

You probably spotted that lots of methods and functions in the Go standard library return a value of type `error`.

`error` is a _predeclared_type_, just like `int`, `string`, etc.

`error` is an interface, it's declaration is

 type error interface {
         Error() string
 }

Any type that has an `Error()`string` method, _implements_ the `error` interface.

* Nil

`nil` is Go's version of `NULL`, `null`, `void`.

- The zero value of an interface type is `nil`.
- The zero value of a pointer type is `nil`.

Go uses the `error` interface and a simple convention to implement error handling.

- If no error occurs, the `err` value returned from a function or method will equal nil.
- If an error occurs, the `err` value returned from a function or method will not equal nil.

 if err != nil {
          // cleanup and handle error
 }

* Counting the number of lines in a file

Now we know about `io.Reader`'s, `error`'s, we can write some more useful programs.

The code for this kata is in `$GOPATH/src/katas/countlines`

_Note_:

- `go`test` always executes from the package's source directory, this makes it simple to include fixtures for your tests.
- The go tool ignores any directory called `testdata`, or starts with a `.` or `_`.

* defer

In `CountLines` from our previous example, if an error happened during reading lines, `f` may not be closed.

Go has a keyword `defer` to ensure operations _always_ happen.

.code -edit src/defer/defer1.go /START OMIT/,/END OMIT/

* Error handling (cont.)

In the previous counting example, if an error happened, the program would exit.

In this kata, we'll handle errors by returning them to the caller.

The code for this kata is in `$GOPATH/src/katas/errorhandling`

* Passing in a reader

Let's turn out `Countlines` function into a program.

The code for this kata is in `$GOPATH/src/katas/linecount`

Complete the program so it reads the number of lines sent to it via stdin.

 % cat testdata/moby.txt | ./linecount
 22659

* Handling multiple files

Let's extend our `linecount` program to handle files passed on the command line.

The code for this kata is in `$GOPATH/src/katas/countmanyfiles`

Complete the program so it counts the lines in files passed via the command line.

 % ./countmanyfiles testdata/*.txt
 testdata/dracula.txt    15973
 testdata/pride-and-prejudice.txt        13427
 testdata/sherlock.txt   13052

* Reading all the *.txt files in a directory

In the previous example we used the shell to list files to process.

In this kata, let's extend our `countmanyfiles` program to walk the directory listing itself.

To do this we use the [[https://golang.org/pkg/os/#File.Readdir][`ReadDir`]] method on [[https://golang.org/pkg/os/#File][`os.File`]].

_Note_: Be careful to only read _files_, not directories, and do not read files that don't end in `.txt`

The code for this kata is in `$GOPATH/src/katas/countdir`

Complete the program so it counts the lines in files passed via the command line.

 % ./countdir testdata/
 testdata/christmas-carol.txt    4236
 testdata/tom-sawyer.txt 9209

* Let's take a break

* HTTP request

The Go standard library supports writing HTTP clients and servers with the [[https://golang.org/pkg/net/http/][`net/http`]] package.

Using the `net/http` package is very straight forward:

 resp, err := http.Get("http://example.com/")
 if err != nil {
         // handle error
 }

`resp` is a [[https://golang.org/pkg/net/http/#Response][`http.Response`]] structure, which has lots of interesting fields.

Let's write a simple HTTP client that can fetch HTTP URLs.

 % ./httpget http://httpbin.org/ip
 {
   "origin": "125.203.122.114"
 }

The code for this kata is in `$GOPATH/src/katas/httpget`

* JSON parsing

The service at `http://httpbin.org/` returns JSON bodies.

The [[https://golang.org/pkg/encoding/json/][`encoding/json`]] package can decode JSON data into a map.

 result := make(map[string]string)
 dec := json.NewDecoder(resp.Body)
 err := dec.Decode(&result)
 if err != nil {
         // handle error
 }

Let's use this to write a program that will tell us our public IP address.

 % ./whatismyip
 My IP address is: 125.203.122.114

The code for this kata is in `$GOPATH/src/katas/whatismyip`

* JSON encoding

If you're writing a RESTful web service it's common to have to return JSON encoded data.

In Go the [[https://godoc.org/encoding/json][`encoding/json`]] package can turn Go maps and data structures into JSON.

.play -edit src/jsonenc/jsonenc1.go /START OMIT/,/END OMIT/

* Controlling JSON encoding

The `encoding/json` package requires the fields of a struct to be public (start with an upper case letter), this means the keys in your JSON document will be upper case.

We can fix this and control the output of the JSON with a _tag_.

The format of the JSON tag is documented on the [[https://golang.org/pkg/encoding/json/#Marshal][`json.Encode`]] method.

.play -edit src/jsonenc/jsonenc2.go /START OMIT/,/END OMIT/

* JSON encoding kata

The code for this kata is in `$GOPATH/src/katas/jsonenc`

* Writing HTTP servers

Go's [[https://golang.org/pkg/net/http][`net/http`]] library can be used to write production web applications.

Writing web servers in Go can be as simple as a few lines. Here is an example:

.play -edit src/http/http1.go

* Writing http servers (cont.)

This is a simple HTTP handler

 func index(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintln(w, "This is the index page")
 }

it takes two parameters

- `w`, a `http.ResponseWriter` which is used to send data to the client
- `r`, a `http.Request` which contains the uri, query parameters, and request body.

 mux := http.NewServeMux()

`http.NewServeMux` returns a `ServeMux`, what we usually call a HTTP router.

* Writing http servers (cont.)

 mux.HandleFunc("/", index)

Registers our `index` function, with the top level route, `"/"`.

 http.ListenAndServe(":8000", mux)

Opens a socket on port 8080 and sends and requests to our `mux` (our router).

`http.ListenAndServe` won't return unless something happens to that listening socket (wifi drops, cable unplugs)

* go get

`go`get` is a simple wrapper around `git` that knows how fetch packages from GitHub (and a few other places).

If a package's import path follows the `go`get` convention, `go`get` knows how to fetch the source code and download it to your `$GOPATH`.

`go`get` isn't a complete dependency manager like rubygems or npm, etc, but it good enough for writing many applications.

We'll use `go`get` to fetch the source for `gorilla/mux`, a more advanced HTTP router

 % go get github.com/gorilla/mux
 % ls $GOPATH/src/github.com/gorilla/mux
 LICENSE                 context_gorilla.go      context_native_test.go  mux_test.go
 README.md               context_gorilla_test.go doc.go                  old_test.go
 bench_test.go           context_native.go       mux.go                  regexp.go
 route.go

* Using gorilla/mux

The standard HTTP router, `http.ServeMux` is quite basic, so we'll upgrade to the `gorilla/mux` http router.

.play -edit src/http/http2.go

* Line counting HTTP service

Let's write a HTTP service that counts the lines in a book via http.

Features:

- When the client requests `/books/{book}` we look up the book and return the number of lines counted.
- The response to the client should be in JSON format and include the number of lines and the title of the book.
- Book directory is configurable.

 % ./httplinecount ../../../books/ &
 [1] 17554
 % curl http://localhost:8080/books/moby.txt
 {"title":"moby.txt","lines":"22659"}

The code for this kata is in `$GOPATH/src/katas/httplinecount`

* Time for a break

* Packages and applications

- how to write a package
- how to layout a project
- package, project katas

* Documenting packages with comments

Go code is traditionally documented with comments in the source code. This is similar to Python's heredoc convention.

Here are some examples

 // simplestrings provides simple helper functions to work with strings
 package simplestrings

 // APIVersion is the version of this package's API
 const APIVersion = 3

 // NextID returns the next ID in the sequence
 func NextID() uint64 { ... }

_Notes_

- Comments directly precede the thing they apply to, don't put an extra newline in between the comment and the symbol
- You should comment both Public and private symbols, but godoc will only show you the documents

* Scope

We've talked about all the ways to declare a variable in Go, now we need to discuss scope.

.code -edit src/scope/scope1/main.go

This program declares `x` four times. All four `x` 's are _different_ because they exist in different scopes.

- Follow [[https://play.golang.org/p/nIcOXVXgwl][this link]] and press the *Run* button.

* Scope (cont.)

The scope of a declaration is bound to the closest pair of curly braces, `{` and `}`.

.code -edit src/scope/scope2/main.go

In this example, we declare `x` to be 100 inside `main`, and 200 inside `f`.

- Follow [[https://play.golang.org/p/Xfi3GOhTiC][this link]] and press the *Run* button.
- Did the program print what you expected?

* Scope (cont.)

What do you expect this program will print?

.code -edit src/scope/scope3/main.go

- Follow [[https://play.golang.org/p/7uxrebFzmK][this link]] and press the *Run* button.
- Did you guess the right answer?

* Scope (cont.)

What do you expect this program will print?

.code -edit src/scope/scope4/main.go

- Follow [[https://play.golang.org/p/7hpZre9LhI][this link]] and press the *Run* button.
- Did you guess the right answer?

* Shadowing

What you are seeing is called _shadowing_.

.code -edit src/scope/scope5/main.go /START1 OMIT/,/END1 OMIT/

Most of you will be comfortable with a _function_scoped_ variable shadowing a _package_scoped_ variable.

.code -edit src/scope/scope5/main.go /START2 OMIT/,/END2 OMIT/

But a _block_scoped_ variable shadowing a _function_scoped_ variable may be surprising.

* Conclusion

* Conclusion

Thank you very much for participating today, I hope that you enjoyed yourself and are encouraged to learn more about Go.

I would like to recommend several online resources:

.link https://tour.golang.org/welcome/1 tour.golang.org
.link https://gobyexample.com/ Go by example

I would like to recommend two books:

.link https://www.amazon.co.jp/exec/obidos/ASIN/4621300253 ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªGo
.link https://www.amazon.co.jp/exec/obidos/ASIN/477418392X/ ã¿ã‚“ãªã®Goè¨€èªã€ç¾å ´ã§ä½¿ãˆã‚‹å®Ÿè·µãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã€‘

