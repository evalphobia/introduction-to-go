Goイントロダクション
Tokyo, Japan
10 Dec 2016

Dave Cheney
dave@cheney.net
http://dave.cheney.net/
@davecheney

* ライセンスと資料について

このプレゼンテーションは[[https://creativecommons.org/licenses/by-sa/4.0/][クリエイティブ コモンズ 表示 継承 4.0 国際]]の下に提供されています。

プレゼンテーションの資料はGithub上で入手できます。

.link https://github.com/davecheney/introduction-to-go


資料に対してリミックス、改変、構築をする際は適切なクレジットを表示し、同じライセンスの下で再配布することができます。

もしこのプレゼンテーションについて提案や修正がある場合は、[[https://github.com/davecheney/introduction-to-go/isues][GitHubプロジェクトのイシューを作成してください]]

* アジェンダ

このワークショップは他のプログラミング言語の経験があり、Goにそのスキルを適用する方法を学びたいプログラマーを対象にしています。

このワークショップは5つのメインセクションで構成されています。

- 基本構文
- 高度な構文Advanced Syntax
- 開発環境とツール
- 標準ライブラリ
- パッケージとアプリケーション

各セクションの後には質問のための時間があります。

私たちが今日取り組んでいる間は会話が少なくなり、Goを習得するのに役立つエクササイズを多く行います。

* プログラミング言語Go

- モダン
- コンパクト, 完結, 汎用的
- 命令型, 静的型チェック, 動的型安全
- ガベージコレクション
- 静的リンクされたネイティブコードへのコンパイル
- 高速なコンパイル, 効率的な実行

プログラマーがプログラマーのために設計しました！

.link https://talks.golang.org/2014/taste.slide#2 出典: Robert Griesemer, A Taste of Go.

* 速度

Goは高速なコンパイルでよく知られていますが、これはGoがプログラミングするために _速い_ 言語であるというアイデアのほんの一面に過ぎません。

「静的言語が "遅くて苦痛" であり、動的言語が "速くて楽しい" という誤った二分法」 - Rob Pike

「下手な型システムは人々を動的に型付けされた言語へ追いやる」 - Robert Griesemer

Goは作成したプログラムという点で高速であり、作成者にとっても高速（生産的？）であるという両方を可能にする言語ということを実証することを試みています。

* 安全性

- 型指定, そして型安全

 var i int = -1
 var u uint = 200
 i = u   // ダメです, 互換性のない型です

- 配列アクセスでは境界チェックされる

 s := make([]string, 10)
 x := s[20] // 実行時にpanicします

- 明示的に初期化されない場合、全てのメモリはゼロになっています

 var q int       // 0 で初期化されます
 var f = 7       // 7 で初期化され, デフォルトの型はintになります

- 暗黙的な変換はしません。ブール値と整数はエイリアスではありません

 i := 2
 if i { ... }    // ダメです, ブールへの型強制はありません

* 並行処理と通信の優れたサポート

- マルチコアCPUが現実のものになります。
- マルチプロセッシングが解決策ではありません。
- ランタイムに統合されたネットワーク処理は標準ライブラリに組み込まれてサポートされています。

* ガベージコレクション

Goはガベージコレクションを持つ言語です。

- 共有された値の所有権に関連する記録のエラーを排除します
- Eliminates an entire class of use after free and memory leak bugs.（？）
- よりシンプルでクリーンなAPIを可能にしています。

The garbage collector handles heaps into the 100's of GB range, and is designed for extremely low "stop the world" pauses.（？）

(ガベージコレクタはGBの範囲のヒープを処理し、そしてとても短い"世界を止める"停止時間のために設計されています )

Go 1.7では、これらの停止時間は100マイクロ秒未満になっています。

* Opinionated

Goは自分の意見を持った言語です。

- 未使用のローカル変数はエラーとなります。
- 未使用のインポートもまたエラーとなります。
- コンパイラは警告を出力しません。エラーを発生させます。
- `go`fmt` がコードの書式フォーマットする単一の方法になります。

* ハロー, http!

.play -edit src/hellohttp/hellohttp_jp.go

* 基本構文

* 基本構文

このセクションでは、簡単なGoプログラムの基本構文について説明していきます。

このセクションの全ての演習コードはスライドの中に組み込まれています。

このセクションを終えると次のことが分かるでしょう。

- 定数と変数の宣言方法
- `for` ループと `if` の使い方
- 型の仕組み
- 独自の関数の書き方
- パッケージと `import` 文の仕組み

* 定数

_定数_ はGoについて話し始めるのに良い箇所でしょう。

定数は変わらない値です

以下は定数の例となります

 1
 "こんにちは"
 false
 1.3

これらは値の評価が定数自体によって行われており、 _リテラル定数_ と呼ばれます

* 定数の型

定数の型には6種類あります

- 整数定数: `1`, `0`, `-6`, `9999999999999999999`, …
- 浮動点小数: `3.14`, `7.5e-2`, …
- 複素数定数（まれ）: `1`-`0.707i`, …
- 文字列定数: `"Hello,`東京"`, …
- ルーン定数: `'a'`, `'す'`, `'シ'`, `'1'`, …
- ブール定数: `true`, `false`

* const

定数を作るには、 `const` キーワードで定数を宣言します

.play -edit src/const/const1/main.go /START OMIT/,/END OMIT/

スライド上で *Run* ボタンが表示された時は、コードを実行することができます。

- *Run* ボタンを押して、何が起こるか見てみてください
- *Close* ボタンを押すと、出力ウィンドウが閉じます

スライド内のコードを直接編集することもできます。


- コードを編集し、名前をあなたのものに置き換えてください
- Goの全てのコードは UTF-8なので、漢字を使うことが出来ます
- *Run* ボタンを押して結果を見てみてください
- もし間違えた場合は、ページをリロードしてください

* 識別子

_識別子_ について話す良い機会ですね

識別子とは、コード内の何かに付ける名前です

Goの識別子は、_文字_ で始まる単語になります

.play -edit src/identifier/identifier1/main.go /START OMIT/,/END OMIT/

文字とはUnicode上で文字として定義されているもので、漢字やキリル文字、ラテン文字などが含まれます。

- 識別子はASCII文字に制限されていません。スライドを編集し、 `students` を `学生数` へ変更して *Run* を押してみましょう
- もし間違えた場合は、ページをリロードしてください

* 識別子 (続き)

識別子は、Unicode文字またはアンダースコア（_）で始まる必要があります

数値は識別子の先頭では許可されていませんが、2文字目以降では可能です

.play -edit src/identifier/identifier2/main.go /START OMIT/,/END OMIT/

これらは _無効な_ 識別子の例となります

- プログラムのコンパイルするように識別子の名前を変更してください
- *Run* ボタンを押して結果を確認してみてください
- もし間違えた場合は、ページをリロードしてください

* コメント

Goは2種類のコメントをサポートしています

- インラインコメントは二重のスラッシュ「//」で始まります
- ブロックコメントはスラッシュとスター「/*」で始まり、スターとスラッシュ「* /」で終わります

.play -edit src/comments/comments1/main.go /START OMIT/,/END OMIT/

コメントアウトされたコードはコンパイル、実行されません。

- このプログラムのコメントを削除してコンパイルするようにしてください
- *Run* ボタンを押して結果を確認し、コンパイルされ`1`2`3`が出力されます
- もし間違えた場合は、ページをリロードしてください

* 宣言

Goの _宣言_ には6種類あり、既にそのうちの1つは見ています。

それらは、

- `const`: 新しい定数を宣言します
- `var`: 新しい変数を宣言します
- `type`: 新しい型を宣言します
- `func`: 新しい関数、またはメソッドを宣言します
- `package`: その `.go` ソースファイルが属するパッケージを宣言します
- `import`: そのパッケージが他のパッケージの宣言をインポートする宣言をします

このセクションでは残りの5つの宣言についてそれぞれ説明します。

* 変数

変数はそのうちに変更が可能な値を保持します。

`var` 宣言によって新しい変数を _宣言_ します

.play -edit src/variable/variable1/main_jp.go /START OMIT/,/END OMIT/

定数のように、変数の _識別子_ はUnicodeとして有効な文字を使うことができます。

- *Run* ボタンを押して結果を確認してください

_注_： 円周は科学的記数法で出力されています😕 ですが大丈夫です。後で `fmt` パッケージについて話す時に修正する方法を話します。

* 未使用変数の宣言

未使用の変数はよくバグの原因となります。もし関数のスコープ内で変数を宣言しそれを使わなかったら、Goのコンパイラは文句を言うでしょう。

もし変数が未使用なら、それを削除するか、一時的に `_` というマジック変数へ代入すべきです。

.play -edit src/variable/variable2/main.go /START OMIT/,/END OMIT/

このプログラムには4つの未使用の変数があります。

- 下の2行のコメントを取り除くようにプログラムを修正してください
- `自転車` の宣言は使われていないので、削除またはコメントアウトしてください
- *Run* ボタンを押してコンパイルされることを確かめてください

* 命令文

_命令文_ は何かを行うためのコマンドです。

- 新しいint型変数xを宣言し、値に10を割り当てる
- xに4を加え、結果をyに格納する
- xが20未満の場合は以下の命令文を実行する

Goにはいくつかの種類の命令文がありますが、すでにいくつか見てきました。 最も一般的な命令文は次のとおりです。

- 宣言: `const`pi`=`3.14159265359`, `type`Counter`int32`, …
- 代入: `count`=`count`+`1`, …
- インクリメント/デクリメント: `x++`, `y--`
- 条件: `if`…`{`…`}`else`{`…`}`, `switch`{`…`}`
- ループ: `for`…`{`…`}`
- 制御フロー: `break`, `fallthrough`, `continue`, `goto`, `return`.

* 代入

変数に格納されている値は変更する必要があるのが普通です。これは _代入_ と呼ばれます。

.play -edit src/assignment/assignment1/main.go /START OMIT/,/END OMIT/

この例では、（を宣言しています）

- *Run* ボタンを押して  `1`, `2`, `4` が出力されることを確かめてください
# - `y` よりも2倍大きな値をもつ新たな変数 `z` を宣言するようにプログラムを更新してください

* 代入 （続き）

新しい値は _変数_ にだけ代入することができます。

.play -edit src/assignment/assignment2/main.go /START OMIT/,/END OMIT/

定数に新しい値を代入するとシンタックスエラーになります。

- *Run* ボタンを押してプログラムがコンパイルできないことを見てみてください。
- サンプルコードを編集し、`x` の宣言を定数(`const`)から変数(`var`)へ変えてください
- *Run* ボタンを押してプログラムがコンパイルされ、正しい答えの 2 が出力されることを確かめてください

* インクリメントとデクリメント

Goは限られた形式の後置インクリメントと後置デクリメントをサポートしています。
例.  `x++`, `x--`

.play -edit src/increment/increment1/main.go /START OMIT/,/END OMIT/

- *Run* ボタンを押してプログラムが2を出力することを見てみてください
- サンプルコードを編集し、デクリメント演算子 `i--` を使って `i` から `1` を引いてください
- *Run* ボタンを押してプログラムがコンパイルされ、正しい答えの 0 が出力されることを確かめてください

* インクリメントとデクリメント（続き）

`i++` と `i--` は _命令文_ であり、 _式_ ではないため、値を生み出しません。

.play -edit src/increment/increment2/main.go /START OMIT/,/END OMIT/

このプログラムにはシンタックスエラーがあります。

- `i++` 命令文を `var`j` 宣言の上へ移動させてエラーを直すようサンプルコードを編集してください
- *Run* ボタンを押してプログラムがコンパイルされ、正しい答えの 2, 2 が出力されることを確かめてください

* ループ

Goには単一の `for` ループ構造があり、

- `while` _条件_ `{`…`}`
- `do`{`…`}`while` _条件_
- `do`{`…`}`until` _条件_

を一つの構文へとまとめています。

- `for` _(初期化)_; _条件_; _(事後処理)_ `{`…`}`

`for`文の構成は以下の通りです。

- 初期化： ループ変数の初期化のために使われます; `i`=`0`
- 条件： ループが終了するかどうかのために使われます; `i`<`10` が `真` ならループが続きます
- 事後処理： ループ変数の増分のために使われます; `i++`, `i`=`i`-`1`

* ループ （続き）

ループの練習をしましょう。

.play -edit src/loops/loops1/main.go /START OMIT/,/END OMIT/

このプログラムは `1` から `10` まで数えますが、 _偶数_ だけを出力することができますか。

- プログラムを編集し、 `1` から `10` までの偶数だけを出力するようにしてください。
- *Run* ボタンを押してプログラムがコンパイルされ、正しい答えの `2`, `4`, `6`, `8`, `10` が出力されることを確かめてください

_注_： `for` の条件の横に `(` `)` のかっこをつける必要はありません。実際には付けるとシンタックスエラーになります。試してみてください。

* ループ （続き）

カウントダウンの練習をしましょう。これは他の言語だと `while` ループを使う場所になります。

.play -edit src/loops/loops2/main.go /START OMIT/,/END OMIT/

このプログラムは `10` から `1` までカウントダウンしますが、 `7` から `3` までカウントするようにしてください。

- プログラムを編集し、 `7` から `3` までの数値だけを出力するようにしてください。
- *Run* ボタンを押してプログラムがコンパイルされ、正しい答えの `7`, `6`, `5`, `4`, `3` が出力されることを確かめてください

_注_： この `for` ループは _条件_ だけがあります。 _初期化_ や _事後処理_ はないため、セミコロン `;` は省略することができます。

* 条件文

Goには2つの条件文、 `if` と `switch` があります。

`if` は _条件_ にもとづき、2つの選択肢から選ぶために使われます。

 if v > 0 {
         println("vは0より大きい")
 } else {
         println("vは0より小さいか同じ")
 }

場合によっては `else` ブロックは省略することができます。これはメソッド・関数の前提条件をチェックする際によく使われます。

 if v == 0 {
         // 何もしない
         return
 }
 // vを処理する

* if

前の偶数の `for` ループの例をもう一度見てみましょう。

.play -edit src/conditionals/conditionals1/main.go /START OMIT/,/END OMIT/

このプログラムは `1` から `10` まで数えます。 _偶数_ だけを出力することができますか。

- `if`i%2`==`0`{` と `}` のコメントを取り、 `1` から `10` までの偶数だけを出力するようにしてください
- *Run* ボタンを押してプログラムがコンパイルされ、正しい答えの `2`, `4`, `6`, `8`, `10` が出力されることを確かめてください

_注_：  `%` はGoでの _剰余_ の演算子です。全ての偶数は完全に2で割りきれ、剰余（または余り）は0になります。

* continue

Javaのような言語と違い、Goでの `if` 文はしばしば _ガード節_ として使われます。

全てが真のとき、コードはページの上から下へと読まれます。

前のプログラムは、ループの内容をスキップする `continue` という新しい文を使って書き直すことができます。

.play -edit src/conditionals/conditionals2/main.go /START OMIT/,/END OMIT/

- `if`i%1`==`1`{`, `continue`, `}` のコメントを取ってください
- *Run* ボタンを押してプログラムがコンパイルされ、正しい答えの `2`, `4`, `6`, `8`, `10` が出力されることを確かめてください

* break

このプログラムは無限ループになります。 `for` ループ内に _条件式_ がありません。

現在のループから抜ける `break` 文を使って、修正することができます。

.play -edit src/conditionals/conditionals3/main.go /START OMIT/,/END OMIT/

- `if`i`>`10`{`, `break`, `}` のコメントを取ってください
- *Run* ボタンを押してプログラムがコンパイルされ、正しい答えの `2`, `4`, `6`, `8`, `10` が出力されることを確かめてください

* 型推論

これまでの例では型についての話題は避けてきました。これはGoが _型推論_ をサポートしているためです。

型推論は、宣言時に変数の型を省略できます。

例えば、

 var i = 7

Goは `i` が宣言され、 `7` という値で初期化されることを知っているため、コンパイラは `i` の型を `int` だと推測します。

しかし、もしも

 var s = "seven"

とすると、Goは `s` が _文字列_ の `"seven"` で初期化されることを知っており、コンパイラは `s` の型を `string` と推測します。

* 明示的な型宣言

場合によっては、Goに特定の型を使うように指示したいときがあるでしょう。

変数を宣言するときにこうします。

 var i int = 4
 var s string = "おはようございます"

これはコンパイラに対して明示的に `i` を `7` の `int` 、 `s` は `"おはようございます"` という値の `string` だと宣言しています。

次のスライドでGoがサポートする種類の型について説明します。

* 型

GoはJavaやC、C++やPythonのように強い型付けの言語です。Goは9種類の型があります。それは、

- 文字列: `string`
- 符号付き整数: `int8`, `int16`, `int32`, `int64`
- 符号なし整数: `uint8`, `uint6`, `uint32`, `uint64`
- エイリアス: `byte`, `rune`, `int`, `uint`
- ブーリアン: `bool`
- IEEE 浮動小数点数: `float32`, `float64`
- 複素数型: `complex64`, `complex128`
- 複合型: `array`, `slice`, `map`, `struct`
- ポインタ型: `*int`, `*bytes.Buffer`

* 文字列型

文字列はGoのプログラムでもっとも一般的な型です。

文字列型は他の言語で期待する通りに動作します。

.play -edit src/strings/strings1/main.go /START OMIT/,/END OMIT/

文字列は `+` 演算子で連結することができます。

- *Run* ボタンを押してプログラムが結果を見てみてください

_注_： Goでの空文字は `""` です。 `null` や `nil` ではありません。

* 整数型

整数型は２番目に一般的です。

整数型には２つの種類があります。 _符号付き_ と _符号なし_ です。

整数型にはまた、ビット数で表現されるいくつかの大きさがあります。

- 符号付き整数: `int8`, `int16`, `int32`, `int64`.
- 符号なし整数: `uint8`, `uint16`, `uint32`, `uint64`.

Goは２つの整数型があり、

- `int`, プラットフォームに応じて `int32` か `int64` のエイリアスになります
- `uint`, プラットフォームに応じて `uint32` か `uint64` のエイリアスになります

この大きさはGoプログラムをビルドしたプラットフォームによって異なります。

* 整数型 （続き）

なぜGoはこんな多くの整数型をサポートしているのでしょうか？

異なる _サイズ_ の整数型は異なる範囲の数に対応することができます。

.play -edit src/types/types1/main.go /START OMIT/,/END OMIT/

このプログラムは2つの型エラーを含んでいます。

- *Run* ボタンを押して、2つの型エラーを発見してください
- 宣言された `x` と `y` を変更し、プログラムを修正してください。
- *Run* ボタンを押してプログラムがコンパイルされ、正しい答えの `400`, `-7` が出力されることを確かめてください

* 関数

今度は _関数_ についてお話しましょう。

全てのGoは関数で構成されています。実際に、あなたはすべて関数を記述してきました。

.play -edit src/functions/functions1/main.go /START OMIT/,/END OMIT/

これは前の例と同じプログラムで、前は隠されていた _関数宣言_ を示しています。

- 全てのGoプログラムは `main` と呼ばれる関数で始まり、これを _メイン関数_ と呼びます

* func

`func` 宣言で、独自の関数を宣言することができます
関数名は `const` や `var` 同様に、有効な識別子でなければなりません

.play -edit src/functions/functions2/main.go /START OMIT/,/END OMIT/

このプログラムは２つの関数 `main` と `hello` を宣言しています

- `func`hello` の `println("こんにちは")` 文のコメントを外してください
- *Run* ボタンを押してプログラムがコンパイルされ、 こんにちは が3回出力されることを確かめてください

_注_： `println` は _組み込み_ の関数で、宣言する必要がありません

* 関数の引数

関数を便利にするためには、関数へ引数を渡すことが必要になるでしょう

関数へ引数を渡すには、引数の型と _仮引数_ の型が同じでなくてはなりません

.play -edit src/functions/functions3/main.go /START OMIT/,/END OMIT/

このプログラムでは、 `hello` に渡される引数と `name` パラメータの型が一致していません

- パラメータと引数の型が一致するように、宣言された `hello` を修正してください
- *Run* ボタンを押してプログラムがコンパイルされ、 `こんにちは`David` が出力されることを確かめてください

* パッケージ

パッケージとは、Goで共有され再利用されるソフトウェアの単位です。すべてのGoコードはパッケージにまとめられています

同じパッケージ内の各ソースファイルは、同じ `package` 宣言で始まらなければなりません
パッケージ名は `const`, `var` や `func` のように有効な識別子でなければなりません

.play -edit src/packages/packages1/main.go

これは前のスライドと同一の例で、`package`宣言を示しています

`package`main` はあなたのプログラムのエントリポイントの `func`main` を含むパッケージの名前になります

* main パッケージ

この間違ったパッケージ宣言をしています

.play -edit src/packages/packages2/main.go

- *Run* ボタンを押してコンパイルエラーを見てみてください
- プログラムがコンパイルされるように `package` 宣言を変更してください
- *Run* ボタンを押してプログラムがあいさつを出力することを確かめてください

* インポート

このセクションでの最後の宣言は _import_ 宣言です

`import` 宣言で、他の _パッケージ_ からあなたのパッケージのコードを使うことができます。

パッケージを `import 'すると、_public_型、関数、変数、型、および定数がパッケージ名の接頭辞とともに使用できます。

パッケージを `import` するとパッケージ名のプリフィクスとともに、 _公開型_ 、 関数、変数、型、そして定数を利用することができます。

 time.Now	// timeパッケージのNow関数を示しています

* インポート（続き）

留意点として、

 import "fmt"
 import "time"

と、

 import (
         "fmt"
         "time"
 )

両方とも `fmt` と `time` パッケージをインポートしています。シンタックスは違いますが、両方とも同じです。

* インポート（続き）

`import` 宣言はパッケージ宣言の _後_ で、 `type`, `const`, `var`, or `func` 宣言の前でなくてはなりません。

.play -edit src/imports/imports1/main.go


このプログラムは `import` 宣言が間違った場所にあるので、コンパイルされません。

- `var`now`=`time.Now()` 宣言を `import` 宣言の _下_ へ移してください
- *Run* ボタンを押してプログラムが現在の時間を出力することを確かめてください

* インポート（続き）

パッケージには _public_ と _private_ の両方のシンボルが含まれています。これらはそれぞれ _公開_(exported)_ と _非公開_(not_exported)_ とも呼ばれます。

.play -edit src/imports/imports2/main.go

このプログラムは２つの _private_ シンボルを参照しているためコンパイルされません

- `Println` と `Time` の正しい大文字小文字を使い、プログラムを修正してください
- *Run* ボタンを押してプログラムが現在の時間を出力することを確かめてください

_注_: もしこのスライドを [[https://go-talks.golang.org/][gotalks.golang.org]] で動かしている場合はに、時刻が `2009-11-10`23:00:00`+0000`UTC` として出力されるかもしれません。これは技術的な制限によるものです。

* fmt パッケージ

あなたはこのプログラムを覚えていますか？

.play -edit src/imports/imports3/main.go

ここでもまた、 `func`, `package` そして `import` 宣言が現れ、完全なGoプログラムになっています。

このプログラムは `fmt` パッケージの `Println` 関数も使用しています。これは組み込みの `println` 関数よりも優れています。

- *Run* ボタンを押して `fmt.Println` がどのように出力をするか見てみてください

* 要約

あなたはGoの基礎が分かっています！

あなたは以下のことを既に学びました：

- 定数と変数を宣言する方法
- `for` ループ と `if` の書き方
- 型の仕組み
- 独自の関数の書き方
- パッケージと `import` 
- How packages and `import` 文の仕組み

一休みの時間です！

* 応用構文

* 応用構文

このセクションでは、先ほど学んだ事柄のそれぞれについて、もう少し詳しく説明します。

このセクションでは、シンプルなオンラインコードエディタである Go Playground を使って演習を行います。

* コーディングスタイル

全てのGoコードは `gofmt` と呼ばれるツールの実行によって、単一のスタイルガイドに沿ってフォーマットされます

全てのGoコードが一つのスタイルによってフォーマットされていることで、読みやすくなり、コードフォーマットについて口論して時間を無駄にすることを避けることができます。

「Gofmtのスタイルは誰も気に入ってはいない、けれど gofmt は誰もが好きだ」
.caption [[https://go-proverbs.github.io/][Go Proverb]].

Go playground は標準的なGoのスタイルに沿って、あなたのコードをフォーマットしてくれます

- [[https://play.golang.org/p/0Hz57BQdTA][このリンク]] の *Format* ボタンを押して、実際にこれを見てみましょう

* ゼロ値

前の例で、このようなコードを書きました

 var name = "go"
 var counter = 1

`name` と `counter` 変数の _宣言_ と _初期化_ をそれぞれしています。このようなコードでは何が起こるでしょうか？

.code src/zerovalue/zerovalue1/main.go

何が出力されましたか？

- [[https://play.golang.org/p/jioUB0t_LW][このリンク]] の *Run* ボタンを押して、実際にこれを見てみましょう

* ゼロ値（続き）

Goでは、初期化されていないメモリはありません。Goランタイムは各変数に割り当てられたメモリが、使用前から初期化されていることを常に保証します

もしこのように書くと、

 var name string
 var counter int

変数 `name` と `counter` に割り当てられたメモリは、 _初期値_ を提供していないためゼロになります

- `name` の値は、長さゼロの文字列の値である `""` になります
- `counter` の値は、0 になります。なぜならそのメモリの位置に0を入れた場合、それが `int` の値になるためです。

* ゼロ値（続き）

Goの全ての型は、関連する _ゼロ値_ を持っています。その変数のメモリへゼロを入れた場合の値です

- 整数型のゼロ値： `int`, `int8`, `uint`, `uint64`, etc... は `0` です
- 浮動小数点型のゼロ値： `float32`, `float64`, `complex128`, etc... は `0.0` です
- 配列のゼロ値はその要素のゼロ値であり、 例えば `[3]int` は `0`, `0`, `0` です
- スライスのゼロ値は `nil` です
- 構造体のゼロ値は、全てのフィールドがゼロ値です

* 等価

Goは強い型付けの言語なので、2つの変数が等しくなるためには、両方の _型と値_ が同一でなければなりません

_異なる_ 型の2つの変数を比較しようとすると実行時に検出されます

.code src/equality/equality1/main.go

- [[https://play.golang.org/p/LwiJm2xuXK][このリンク]] の *Run* ボタンを押してください
- 宣言された `x` と `y` が _同じ_ 型となるようにプログラムを修正してください
- *Run* ボタンを押して、プログラムが `true` を出力するようになったことを確かめてください

* 型変換

異なる整数型の変数があった際に、 一方の型からもう一方の型へと、 _変換式_ を用いて _変換_ することができます

`T(v)` 式は `v` という値を `T` 型へと変換します

.code -edit src/types/types2/main.go

この例で `y`=`x` という代入は、 `x` と `y` が異なる整数型なので失敗します。

- [[https://play.golang.org/p/wvG41C0lH4][このリンク]] の *Run* ボタンを押してください
- `int(x)` で `x` を `int` へと _変換_ してプログラムを修正してください
- *Run* ボタンを押して、プログラムが `700` を出力するようになったことを確かめてください

* 型変換（続き）

If you have variables of different _widths_, you can _convert_ from one type to another.

.code -edit src/types/types3/main.go

- Follow [[https://play.golang.org/p/l4Q48pWAla][this link]] and press the *Run* button.
- Fix the program by _converting_ `x` to an `int64` with `int64(x)`.
- Press the *Run* button and confirm the program now prints `32000`.

* Type conversions (cont.)

We can do the opposite and convert a wider type to a narrower type.

.code -edit src/types/types4/main.go

- Follow [[https://play.golang.org/p/NbNwRjbmRu][this link]] and press the *Run* button. Does it print the answer you expected?
- Fix the program by _declaring_ `y` as an `int32`.
- Press the *Run* button and confirm the program now prints `64000`.

* Integer overflow

Whenever you declare a variable in Go, you have to choose how many bits of memory it will consume.

When you convert a variable with a _smaller_ number of bits to a variable with a larger number of bits, this is fine, because they all fit.

When you convert a variable with a _larger_ number of bits to a variable with a smaller number of bits there is a risk of truncation, because there are less bits available to represent your number.

- Follow [[https://play.golang.org/p/NbNwRjbmRu][this link]] and press the *Run* button. Does it print the answer you expected?
- Fix the program by reducing the value of `x`. Hint: the value needs to be less than 33,000.
- Press the *Run* button and confirm the program now prints `y` correctly.

* Short declaration syntax

As you've probably noticed, Go has several ways to declare variables. All three of these are the same

 var x = 0
 var x int = 0
 var x int

If you've come from a language like Ruby or Python, you're probably wondering if this very common operation can be made more concise. Indeed it can.

 x := 0

This is what we call a _short_declaration_, which is the same as

 var x int = 0

Short declaration is very common in Go programs, you'll see it everywhere, so let's do some exercises to familarise you with its use.

* Short declaration syntax (cont.)

A common use of the short declaration syntax is in `for` loops. Consider this program

 var i int
 for i = 1; i < 11; i++ {
         fmt.Println(i)
 }

This can be also written as

 for i := 1; i < 11; i++ {
         fmt.Println(i)
 }

[[https://play.golang.org/p/3Vl75w72JO][This program]] contains two `var` declarations and two `for` loops.

- Follow [[https://play.golang.org/p/3Vl75w72JO][this link]] and press the *Run* button.
- Rewrite the program using the short declaration syntax; there should be no `var` declarations, only `:=`.

* Slices

The next kind of type to discuss is the _Slice_.

A slice is an ordered collection of values of a _single_ type.

The syntax for declaring a slice variable is very similar to declaring a _scalar_ variable.

 var i int      // an int called i
 var j []int    // a slice of ints called j

In this example,

- `i` is a variable of type `int`.
- `j` is a variable of type `[]int`, that is, a slice of `int`.

Slices are very important in Go programs, so we'll spend a bit of time discussing them.

_note_: A slice is _not_ an array. Go also supports arrays, but you'll see later than they aren't very common, or very easy to use, so we won't discuss them at the moment.

* How large is a slice?

If I declare a slice, `[]int`, how many items can it hold?

The _zero_value_ of a slice is empty, that is, it has a _length_ of zero; it can hold 0 items.

.code -edit src/slices/slices1/main.go

We can retrieve the length of a slice with the built-in `len` function.

- Follow [[https://play.golang.org/p/gZYvdE2zbT][this link]] and press the *Run* button.
- Did you guess the right answer?

* Making a slice

We can create a slice with space to hold items using the built-in `make` function.

.code -edit src/slices/slices2/main.go

In this example, on the first line `var i []int` declares `i` to be a slice of `int`.

On the second line, `i` is _assigned_ the result of `make([]int,`20)`.

- Follow [[https://play.golang.org/p/i_IWqjik6u][this link]] and press the *Run* button.
- Did `fmt.Println(len(i))` print the result you expected?

* Making a slice (cont.)

Because declaring a slice variable and initalising it with `make` is a common operation, it is common to see the _short_variable_declaration_ used to combine this operations.

.code -edit src/slices/slices3/main.go

This example declares `i` _and_ initalises it to be a slice of `int` with a length of 20.

- Follow [[https://play.golang.org/p/b92SJ0Gx9s][this link]] and press the *Run* button.
- Did `fmt.Println(len(i))` print the result you expected?

* Slice exercises

Let's do a quick exercise to familarise yourself with using slices.

.code -edit src/slices/slices4/main.go

- Follow [[https://play.golang.org/p/AJk1Jgp1iE][this link]] for instructions.
- Declare a variable called `i` which is a slice of 5 `int`.
- Declare a variable called `f` which is a slice of 9 `float64`.
- Declare a variable called `s` which is a slice of 4 `string`.
- Does your program print the expected result, `5`9`4`?

* Index expressions

To access, or assign, the contents of a slice element at index `i`, use the form `s[i]`.

Slices are zero indexed, so `s[0]` is the 1st element, `s[1]` is the second element, and so on.

When the _index_expression_ appears on the _left_hand_side_ of the equals operator, `=`

 s[7] = 20

We are assigning the number 20 to the 8'th element of the slice `s`.

When the _index_expression_ appears on the _right_hand_side_ of the equals operator, `=`

 x := s[7]

We are assigning the value at the 8th element of `s` to the variable `x`.

* Slice zero value

We saw earlier that the _zero_value_ of the slice

 var s []int

was and empty slice, a slice with length of zero.

What is the value of each of the elements of a newly created, with make, slice?

.play -edit src/slices/slices5/main.go

- Follow [[https://play.golang.org/p/kGh_C1l6KW][this link]] and press the *Run* button.
- Did the program print the result you expected?

* Slice initialisation

We want to create an `[]int` slice of the first 10 prime numbers, how could we do this?

One solution could be to create the slice and assign a value to each element in the slice.

.play -edit src/slices/slices6/main.go

* Slice initialisation (cont.)

Doing this manually is verbose and boring; how would you do this for the first 50 primes?

Go supports a method of assignment where we both _declare_ and _initalise_ the slice at once.

.play -edit src/slices/slices7/main.go

This is called the _composite_literal_ syntax.

- Follow [[https://play.golang.org/p/P-eBqzPCWh][this link]] and complete the exercise.

* append

So far we've been using slices with a known length. You can extend the contents of a slice with the built-in `append` function.

.play -edit src/slices/slices8/main.go

`append` increases the length of the slice to accommodate the new items, then returns a new slice value.

You can `append` multiple values in one statement, providing they are all the same type.

.link https://blog.golang.org/slices Further reading: Arrays, slices (and strings): The mechanics of 'append' (blog.golang.org)

* Subslices

What if we have a large slice, and want to refer to only a part of it.

We call this slicing a slice, or _subslicing_.

Subslicing looks similar to the _indexing_ operation we saw a few slide ago, except it refers to a range of slice indexes.

.play -edit src/slices/slices12/main.go

The expression `brothers[0:3]` evaluates to a slice of the 1st to 3rd Marx brother.

- Follow [[https://play.golang.org/p/d1-jl42aTF][this link]] and complete the exercise.

* Subslices (cont.)

An important thing to remember when slicing a slice, is that both slices refer to the _same_ underying data.

.play -edit src/slices/slices10/main.go

To create two independent slice values, you would use the `copy` function, which we'll discuss later.

* Bounds checking

Each slice has a length which is decided when it is made.

You can increase the length of the slice with the `append` function, and create a smaller slice from a larger one using the slice operator.

What happens if you accidentally exceed the bounds of the slice?

.play -edit src/slices/slices11/main.go

- Follow [[https://play.golang.org/p/mIWm0a1amp][this link]] and press the *Run* button.
- Comment out `fmt.Println(primes[-1])` and see what happens.

* Multiple assignment

Go allows you to perform multiple assignments and declarations in one statement.

For example, if we wanted to declare, `x`, `y`, and `z`, with the values `1`, `2`, and `3` respectively. We could write

 var x = 1
 var y = 2
 var z = 3

We can write the same thing like this

 var x, y, z = 1, 2, 3

- Follow [[https://play.golang.org/p/d2hDJQAfkt][this link]] for some examples of multiple declaration.

* Multiple return values

Multiple assignment is important to understand because you can return multiple values from a function.

 func f(i int)

This is a function declaration for `f` which takes one argument, an `int`.

 func g(i int, j int, k string) int

This is a function declaration for `g`, which takes three arguments, two `int` s and a `string`, and returns an `int`.

 func h(i, j int) (int, int, string)

This is a function declaration for `h`, which takes two arguments, two `ints`, and returns three values, two `int` s and a `string`.

* Multiple return values (cont.)

Your program must return the number of values specified in the function signature.

.play -edit src/functions/functions4/main.go

* Assigning multiple return values

When you call a function that returns multiple values, you must assign _all_ of them or _none_ of them.

 func f() (int, bool, string)

 func main() {
         a, b, c := f()
         fmt.Println(a, b, c)
 }

`f` returns three values, so we assign them to `a`, `b`, and `c` using the short declaration syntax.

If we wanted to use only the first and third values we can ignore the second by assigning it to the underscore variable, `_`.

 func main() {
         a, _, c := f()
         fmt.Println(a, c)
 }

* Maps

Go has a built in Hash Map type, called a `map`.

Maps map values of key type K to values of type V

 var m map[string]int

Just like making a slice, making a map is accomplished with the `make` built-in.

.play -edit src/maps/maps1/main.go

* Inserting values into a map

Inserting a value into a map looks similar to assigning a value to a slice element.

.play -edit src/maps/maps2/main.go

If an entry already exits with that key, it will be overwritten.

- Follow [[https://play.golang.org/p/a-V5I0nZ5l][this link]] and complete the exercise.

_note_: maps are always _unordered_.

* Compact literal initalisation

Just like slices, maps support compact literal initalisation, which declares and initalises the map.

.play -edit src/maps/maps3/main.go

* Retrieving a values from a map

Just like a slice, you can retrieve the value stored in a map with the syntax `m[key]`.

If it is present the value will be returned, if not the _zero_value_ will be returned.

.play -edit src/maps/maps4/main.go

* Checking if a map value exists

In the previous slide we saw that `moons["Neptune"]` returned `0`.

How can we tell if Neptune actually has no moons, or if `0` was returned because there is no entry for Neptune?

Map look ups support a second syntax.

.play -edit src/maps/maps5/main.go

* Deleting a value from a map

To delete a value from a map, you use the built in `delete` function.

.play -edit src/maps/maps6/main.go

* Iterating over a map

If we wanted to print out all the values in a map we can use a form of the `for` syntax which is known as `range`.

.play -edit src/range/range1/main.go

`range` loops over each entry in the map, assigning the map key to `name`, and the map value to `pop`.

* Range over slices

We say previously that `for`range` works with maps, it also works with slices.

.play -edit src/range/range2/main.go

- Follow [[https://play.golang.org/p/AmQW-OrPC1][this link]] and complete the exercise.
- If you cannot figure it out, don't worry, there is an answer on the next slide.

* Switch

If you completed the previous exercise you may have written something like this

.play -edit src/range/range2a/main.go /START OMIT/,/END OMIT/

Heavily nested `if`else`if` blocks are discouraged in Go.

Instead we can use the other condition statement, `switch`.

* Switch (cont.)

`switch` can be used

.play -edit src/switch/switch1/main.go /START OMIT/,/END OMIT/

* fmt

Let's conclude this section by talking about the fmt package.

`fmt` standard for formatted printing; the name is inherited from Go's Plan 9 legacy.

We've use `fmt.Println` a lot up to this point, but the `fmt` package has many other useful functions.

We'll focus on `fmt.Printf`, the `f` stands for _formatted_output_.

Here is an example.

.play -edit src/fmt/fmt1/main.go /START OMIT/,/END OMIT/

- Follow [[https://play.golang.org/p/UuzPWcwDrE][this link]] to experiment.

* Formatting verbs

If you're used to languages like Python or C, you're probably used to the idea of _formatting_verbs_.

The `fmt` package supports a large number of formatting verbs and modifiers. In the previous example you saw `%s` and `%d`, for `string` and `int` respectively.

The `fmt` package is smart enough to spot when you use the wrong formatting verb, or don't provide enough arguments to `fmt.Printf`.

.play -edit src/fmt/fmt2/main.go /START OMIT/,/END OMIT/

* Formatting verbs (cont.)

Having to choose the correct verb that matches the type of the value you want to print is boring.

To make it easier to use `fmt.Printf` in the simple case, you can use the `%v` verb, which know how to print _any_ value.

.play -edit src/fmt/fmt3/main.go /START OMIT/,/END OMIT/

- Follow [[https://play.golang.org/p/B-E7JOJ1Db][this link]] to experiment with a few more formatting verbs.

* Recap

Now you know most of Go!

You've learnt:

- How Go code is formatted.
- How what the zero value is and how it works.
- Equality and type conversions
- The short declaration syntax
- Multiple assignment.
- How slices work.
- How maps work.
- How the `fmt` package works.

Time for lunch!

* Development environment and tooling

* Development environment and tooling

This section focuses on the developer experience

- Installing Go.
- Setting up a `$GOPATH` workspace.
- Introduction to the `go` command.
- Writing unit tests with the go test command.

* Installing Go

The next few slides give examples of how to install Go on various systems.

The official installation documentation is here:

.link https://golang.org/doc/install

The current version of Go is 1.7.4.

- New minor releases, Go 1.8, Go 1.9, etc, ship twice a year.
- Historically 2–4 bug fix or security releases occur during each six month period.

* Installing Go on OS X

Installing Go on OS X (also known as `darwin`) can be accomplished with

*Max OS Installer*

The Go project provides an `.pkg` installer, use:

.link https://storage.googleapis.com/golang/go1.7.4.darwin-amd64.pkg

*Homebrew*

If you use Homebrew to manage third party software on your Mac, use:

 brew install golang

*MacPorts*

If you use MacPorts to manage third party software on your Mac, use:

 sudo port install go

* Installing Go on Windows

*MSI*Installer*

The Go project provides a `.msi` installer for 32bit and 64bit Windows, use:

.link https://storage.googleapis.com/golang/go1.7.4.windows-amd64.msi Windows 64bit MSI installer
.link https://storage.googleapis.com/golang/go1.7.4.windows-386.msi Windows 32bit MSI installer

*.zip*file*

The Go project provides a `.zip` file of the Go compiler and standard library, use:

.link https://storage.googleapis.com/golang/go1.7.4.windows-amd64.zip Windows 64bit zip file
.link https://storage.googleapis.com/golang/go1.7.4.windows-386.zip Windows 32bit zip file

Unzip the zip file and place it at `C:\Go`.

* Installing Go on Linux

Depending on your Linux distribution they may have an up to date version of Go, but this is rare.

The most reliable way to install the latest version of Go is to untar

.link https://storage.googleapis.com/golang/go1.7.4.linux-amd64.tar.gz

to the directory

 /usr/local

and add

 /usr/local/go/bin

to your `$PATH`.

 echo "export PATH=$PATH:/usr/local/go/bin" >> ~/.bash_profile

* Go tool

Your Go installation comes with a tool we call the `go` tool, because that's its name.

The `go` tool can

- compile your programs
- run your tests
- display documentation for a package
- fetch packages from the internet.

* $GOPATH

The `go` tool works inside a workspace where _all_ your Go source code is stored.

All the source code for this workshop is included with this repository.

You can set `$GOPATH` to be the base directory where you checked out this repository. eg.

 % export GOPATH=$HOME/introduction-to-go

Using a workspace allows you to import code from other packages with a fixed name. eg.

 import "github.com/pkg/profile"

Will import the code for the `profile` package stored in

 $GOPATH/src/github.com/pkg/profile

* go build

Go is a compiled language, so the usual work flow is

- Edit code
- `go`build`
- Run program

Let's try building a Go program

- `cd`$GOPATH/src/helloworld`
- Read the source for `hello.go`
- Build the source with `go`build`
- Run the program `./helloworld`

* What time is it (exercise)

Let's write a clock, a program that prints out the current time

- `cd`$GOPATH/src/whattimeisit`
- edit `main.go` and finish the program (if you get stuck the answer is in `answer.go`)
- Build the program with, `go`build` (if you make an error, go back and edit `main.go`)
- Run your program `./whattimeisit`, it should print something like this

 The current time is 2016-12-05 12:33:18.222821474 +0900 JST

* Testing

I wanted to spend some time on testing because for the rest of the day we'll be using tests to complete code katas.

The testing package can also contain benchmark functions and examples, which show up in godoc.

You should include tests for each package that you write.

The `testing` package is ideal for _unit_tests_. It's _ok_ for functional tests, but not really suitable for complex integration tests.

* go test

`go`test` is the unit testing framework built into the Go standard library. It lives in the `testing` package.

Tests live in `_test.go` files, eg. the `strings` package has these files:

- `strings.go` functions to manipulate UTF-8 encoded strings.
- `strings_test.go` tests for the `strings` package.

Each test is a function in the form

 func TestNameOfTest(t *testing.T) { ... }

- `NameOfTest` is the name of your test, it _must_ start with an upper case letter.
- Test functions take a `testing.T` value, which provides helpers like `t.Error` and `t.Fail`.

* Writing tests

Let's write some tests using our own version of the strings package, called `simplestrings`.

- The code for this exercise is in `$GOPATH/src/simplestrings/`
- Read the source code for `simplestrings.go`

Together we'll write some tests for the functions in our `simplestrings` package.

We'll use the test coverage (see next slide) tool to check our work.

* Test coverage

`go`test` can report coverage

 go test -coverprofile=cover.out

This produces a coverage file, `cover.out`

- `go`tool`cover`-func=cover.out` will print the coverage report
- `go`tool`cover`-html=cover.out` will open the report in a browser

_Protip_: I use these little shell functions to make this easier

 cover () {
   t=$(mktemp -t cover)
   go test $COVERFLAGS -coverprofile=$t $@ && go tool cover -func=$t && unlink $t
 }

 cover-web() {
   t=$(mktemp -t cover)
   go test $COVERFLAGS -coverprofile=$t $@ && go tool cover -html=$t && unlink $t
 }

* The standard library

Go ships with a rich standard library of packages. This includes

- file input / output
- string handling
- compression
- encoding and decoding of JSON and XML
- network handling
- HTTP client and server

* Katas

For the rest of the day let's practice writing Go code together.

The Ruby community have a tradition of _code_katas_, small exercises to make the test pass.

As we work through the katas, we'll visit some more of the Go standard library.

* String formatting

As a warm up, let's do a small kata together.

The code for this kata is in `$GOPATH/src/katas/sprintf`

If you get stuck, the answers are in `$GOPATH/src/katas/sprintf/answers_test.go`.

* Structs

So far we've discussed two kinds of types; _primitive_ types and _slice_ types.

Go supports what we call _compound_ types, that is, types that are _composed_ of other types.

These are called _struct_ (for _structure_) types. We declare a struct like this:

 type Point struct {
          X int
          Y int
 }

`Point` is a position in two dimensional space, it has two fields, `X` and `Y`.

- Complete the kata in `$GOPATH/src/katas/points` by making all the tests pass.

* Methods

To this point we've talked about functions, which belong to a package

 // Max returns the larger of a or b.
 func Max(a, b int) int

In Go, you can attach a function to a type that you declare, this is called a _method_.

 type Point struct { X, Y int }

 func (p Point) String() string {
          return fmt.Sprintf("point: x=%d, y=%d", p.X, p.Y)
 }

Any type that implements a `String()`string` method will be used by the `fmt` package when it prints the value.

- Complete the kata in `$GOPATH/src/katas/methods` by making all the tests pass.

* Pointers

Whenever you pass a value to a function or method, the value is _copied_.

In Go, the method's receiver is also a value, so it's copied when you call a method.

.play -edit src/pointers/pointers1.go /START OMIT/,/END OMIT/

- Complete the kata in `$GOPATH/src/katas/pointers` by making the test pass.

* Interfaces

Go is an object oriented language; we have methods on types, but Go does not support inheritance or sub-classes.

Go supports polymorphism, _has_a_ (not _is_a_) with _interfaces_.

An interface declaration looks like this:

 type Reader interface {
          Read(buf []byte) (int, error)
 }

This is the [[https://golang.org/pkg/io/#Reader][`io.Reader`]] interface declaration from the [[https://golang.org/pkg/io/][`io`]] package.

Go does not have an _implements_ keyword, any type with the correct set of methods _is_ an implementation of the interface.

* Reading input

This kata asks you to write a function that reads lines from an io.Reader and returns a string containing all the lines read.

The code for this kata is in `$GOPATH/src/katas/input`

* Readers

To familarise you with the `io.Reader` implementations available in the `io` package, this kata is all about Readers.

- Complete the kata in `$GOPATH/src/katas/readers` by making the test pass.
- If you get stuck, consult the documentation in the [[https://golang.org/pkg/io/][`io`]] package.

* Error handling

You probably spotted that lots of methods and functions in the Go standard library return a value of type `error`.

`error` is a _predeclared_type_, just like `int`, `string`, etc.

`error` is an interface, it's declaration is

 type error interface {
         Error() string
 }

Any type that has an `Error()`string` method, _implements_ the `error` interface.

* Nil

`nil` is Go's version of `NULL`, `null`, `void`.

- The zero value of an interface type is `nil`.
- The zero value of a pointer type is `nil`.

Go uses the `error` interface and a simple convention to implement error handling.

- If no error occurs, the `err` value returned from a function or method will equal nil.
- If an error occurs, the `err` value returned from a function or method will not equal nil.

 if err != nil {
          // cleanup and handle error
 }

* Counting the number of lines in a file

Now we know about `io.Reader`'s, `error`'s, we can write some more useful programs.

The code for this kata is in `$GOPATH/src/katas/countlines`

_Note_:

- `go`test` always executes from the package's source directory, this makes it simple to include fixtures for your tests.
- The go tool ignores any directory called `testdata`, or starts with a `.` or `_`.

* defer

In `CountLines` from our previous example, if an error happened during reading lines, `f` may not be closed.

Go has a keyword `defer` to ensure operations _always_ happen.

.code -edit src/defer/defer1.go /START OMIT/,/END OMIT/

* Error handling (cont.)

In the previous counting example, if an error happened, the program would exit.

In this kata, we'll handle errors by returning them to the caller.

The code for this kata is in `$GOPATH/src/katas/errorhandling`

* Passing in a reader

Let's turn out `Countlines` function into a program.

The code for this kata is in `$GOPATH/src/katas/linecount`

Complete the program so it reads the number of lines sent to it via stdin.

 % cat testdata/moby.txt | ./linecount
 22659

* Handling multiple files

Let's extend our `linecount` program to handle files passed on the command line.

The code for this kata is in `$GOPATH/src/katas/countmanyfiles`

Complete the program so it counts the lines in files passed via the command line.

 % ./countmanyfiles testdata/*.txt
 testdata/dracula.txt    15973
 testdata/pride-and-prejudice.txt        13427
 testdata/sherlock.txt   13052

* Reading all the *.txt files in a directory

In the previous example we used the shell to list files to process.

In this kata, let's extend our `countmanyfiles` program to walk the directory listing itself.

To do this we use the [[https://golang.org/pkg/os/#File.Readdir][`ReadDir`]] method on [[https://golang.org/pkg/os/#File][`os.File`]].

_Note_: Be careful to only read _files_, not directories, and do not read files that don't end in `.txt`

The code for this kata is in `$GOPATH/src/katas/countdir`

Complete the program so it counts the lines in files passed via the command line.

 % ./countdir testdata/
 testdata/christmas-carol.txt    4236
 testdata/tom-sawyer.txt 9209

* Let's take a break

* HTTP request

The Go standard library supports writing HTTP clients and servers with the [[https://golang.org/pkg/net/http/][`net/http`]] package.

Using the `net/http` package is very straight forward:

 resp, err := http.Get("http://example.com/")
 if err != nil {
         // handle error
 }

`resp` is a [[https://golang.org/pkg/net/http/#Response][`http.Response`]] structure, which has lots of interesting fields.

Let's write a simple HTTP client that can fetch HTTP URLs.

 % ./httpget http://httpbin.org/ip
 {
   "origin": "125.203.122.114"
 }

The code for this kata is in `$GOPATH/src/katas/httpget`

* JSON parsing

The service at `http://httpbin.org/` returns JSON bodies.

The [[https://golang.org/pkg/encoding/json/][`encoding/json`]] package can decode JSON data into a map.

 result := make(map[string]string)
 dec := json.NewDecoder(resp.Body)
 err := dec.Decode(&result)
 if err != nil {
         // handle error
 }

Let's use this to write a program that will tell us our public IP address.

 % ./whatismyip
 My IP address is: 125.203.122.114

The code for this kata is in `$GOPATH/src/katas/whatismyip`

* JSON encoding

If you're writing a RESTful web service it's common to have to return JSON encoded data.

In Go the [[https://godoc.org/encoding/json][`encoding/json`]] package can turn Go maps and data structures into JSON.

.play -edit src/jsonenc/jsonenc1.go /START OMIT/,/END OMIT/

* Controlling JSON encoding

The `encoding/json` package requires the fields of a struct to be public (start with an upper case letter), this means the keys in your JSON document will be upper case.

We can fix this and control the output of the JSON with a _tag_.

The format of the JSON tag is documented on the [[https://golang.org/pkg/encoding/json/#Marshal][`json.Encode`]] method.

.play -edit src/jsonenc/jsonenc2.go /START OMIT/,/END OMIT/

* JSON encoding kata

The code for this kata is in `$GOPATH/src/katas/jsonenc`

* Writing HTTP servers

Go's [[https://golang.org/pkg/net/http][`net/http`]] library can be used to write production web applications.

Writing web servers in Go can be as simple as a few lines. Here is an example:

.play -edit src/http/http1.go

* Writing http servers (cont.)

This is a simple HTTP handler

 func index(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintln(w, "This is the index page")
 }

it takes two parameters

- `w`, a `http.ResponseWriter` which is used to send data to the client
- `r`, a `http.Request` which contains the uri, query parameters, and request body.

 mux := http.NewServeMux()

`http.NewServeMux` returns a `ServeMux`, what we usually call a HTTP router.

* Writing http servers (cont.)

 mux.HandleFunc("/", index)

Registers our `index` function, with the top level route, `"/"`.

 http.ListenAndServe(":8000", mux)

Opens a socket on port 8080 and sends and requests to our `mux` (our router).

`http.ListenAndServe` won't return unless something happens to that listening socket (wifi drops, cable unplugs)

* go get

`go`get` is a simple wrapper around `git` that knows how fetch packages from GitHub (and a few other places).

If a package's import path follows the `go`get` convention, `go`get` knows how to fetch the source code and download it to your `$GOPATH`.

`go`get` isn't a complete dependency manager like rubygems or npm, etc, but it good enough for writing many applications.

We'll use `go`get` to fetch the source for `gorilla/mux`, a more advanced HTTP router

 % go get github.com/gorilla/mux
 % ls $GOPATH/src/github.com/gorilla/mux
 LICENSE                 context_gorilla.go      context_native_test.go  mux_test.go
 README.md               context_gorilla_test.go doc.go                  old_test.go
 bench_test.go           context_native.go       mux.go                  regexp.go
 route.go

* Using gorilla/mux

The standard HTTP router, `http.ServeMux` is quite basic, so we'll upgrade to the `gorilla/mux` http router.

.play -edit src/http/http2.go

* Line counting HTTP service

Let's write a HTTP service that counts the lines in a book via http.

Features:

- When the client requests `/books/{book}` we look up the book and return the number of lines counted.
- The response to the client should be in JSON format and include the number of lines and the title of the book.
- Book directory is configurable.

 % ./httplinecount ../../../books/ &
 [1] 17554
 % curl http://localhost:8080/books/moby.txt
 {"title":"moby.txt","lines":"22659"}

The code for this kata is in `$GOPATH/src/katas/httplinecount`

* Time for a break

* Packages and applications

- how to write a package
- how to layout a project
- package, project katas

* Documenting packages with comments

Go code is traditionally documented with comments in the source code. This is similar to Python's heredoc convention.

Here are some examples

 // simplestrings provides simple helper functions to work with strings
 package simplestrings

 // APIVersion is the version of this package's API
 const APIVersion = 3

 // NextID returns the next ID in the sequence
 func NextID() uint64 { ... }

_Notes_

- Comments directly precede the thing they apply to, don't put an extra newline in between the comment and the symbol
- You should comment both Public and private symbols, but godoc will only show you the documents

* Scope

We've talked about all the ways to declare a variable in Go, now we need to discuss scope.

.code -edit src/scope/scope1/main.go

This program declares `x` four times. All four `x` 's are _different_ because they exist in different scopes.

- Follow [[https://play.golang.org/p/nIcOXVXgwl][this link]] and press the *Run* button.

* Scope (cont.)

The scope of a declaration is bound to the closest pair of curly braces, `{` and `}`.

.code -edit src/scope/scope2/main.go

In this example, we declare `x` to be 100 inside `main`, and 200 inside `f`.

- Follow [[https://play.golang.org/p/Xfi3GOhTiC][this link]] and press the *Run* button.
- Did the program print what you expected?

* Scope (cont.)

What do you expect this program will print?

.code -edit src/scope/scope3/main.go

- Follow [[https://play.golang.org/p/7uxrebFzmK][this link]] and press the *Run* button.
- Did you guess the right answer?

* Scope (cont.)

What do you expect this program will print?

.code -edit src/scope/scope4/main.go

- Follow [[https://play.golang.org/p/7hpZre9LhI][this link]] and press the *Run* button.
- Did you guess the right answer?

* Shadowing

What you are seeing is called _shadowing_.

.code -edit src/scope/scope5/main.go /START1 OMIT/,/END1 OMIT/

Most of you will be comfortable with a _function_scoped_ variable shadowing a _package_scoped_ variable.

.code -edit src/scope/scope5/main.go /START2 OMIT/,/END2 OMIT/

But a _block_scoped_ variable shadowing a _function_scoped_ variable may be surprising.

* Conclusion

* Conclusion

Thank you very much for participating today, I hope that you enjoyed yourself and are encouraged to learn more about Go.

I would like to recommend several online resources:

.link https://tour.golang.org/welcome/1 tour.golang.org
.link https://gobyexample.com/ Go by example

I would like to recommend two books:

.link https://www.amazon.co.jp/exec/obidos/ASIN/4621300253 プログラミング言語Go
.link https://www.amazon.co.jp/exec/obidos/ASIN/477418392X/ みんなのGo言語【現場で使える実践テクニック】

